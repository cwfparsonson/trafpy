

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trafpy.manager.src.schedulers.schedulertoolbox &mdash; TrafPy 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home"> TrafPy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../Install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../Tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../Contribute.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../License.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../Citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../setup.html">setup module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../trafpy.html">trafpy package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">TrafPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
      <li>trafpy.manager.src.schedulers.schedulertoolbox</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for trafpy.manager.src.schedulers.schedulertoolbox</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">json</span>


<div class="viewcode-block" id="SchedulerToolbox"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox">[docs]</a><span class="k">class</span> <span class="nc">SchedulerToolbox</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">RWA</span><span class="p">,</span> <span class="n">slot_size</span><span class="p">,</span> <span class="n">packet_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">time_multiplexing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Graph</span> <span class="o">=</span> <span class="n">Graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RWA</span> <span class="o">=</span> <span class="n">RWA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span> <span class="o">=</span> <span class="n">slot_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet_size</span> <span class="o">=</span> <span class="n">packet_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_multiplexing</span> <span class="o">=</span> <span class="n">time_multiplexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_mode</span> <span class="o">=</span> <span class="n">debug_mode</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

<div class="viewcode-block" id="SchedulerToolbox.reset"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Graph</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SchedulerToolbox.remove_flow_from_queue"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.remove_flow_from_queue">[docs]</a>    <span class="k">def</span> <span class="nf">remove_flow_from_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow_dict</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given flow dict and network that flow is in, will locate flow </span>
<span class="sd">        in network and remove from queue</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">sn</span> <span class="o">=</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span>
        <span class="n">dn</span> <span class="o">=</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;dst&#39;</span><span class="p">]</span>
        <span class="n">queued_flows</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">sn</span><span class="p">][</span><span class="n">dn</span><span class="p">][</span><span class="s1">&#39;queued_flows&#39;</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_flow_idx</span><span class="p">(</span><span class="n">flow_dict</span><span class="p">,</span> <span class="n">queued_flows</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">sn</span><span class="p">][</span><span class="n">dn</span><span class="p">][</span><span class="s1">&#39;queued_flows&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">sn</span><span class="p">][</span><span class="n">dn</span><span class="p">][</span><span class="s1">&#39;completion_times&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">network</span></div>

<div class="viewcode-block" id="SchedulerToolbox.filter_unavailable_flows"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.filter_unavailable_flows">[docs]</a>    <span class="k">def</span> <span class="nf">filter_unavailable_flows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Takes a network and filters out any flow that is not ready to be scheduled</span>
<span class="sd">        yet i.e. has incomplete parent flow dependencies. Use this method to get</span>
<span class="sd">        network representation for &#39;job-agnostic&#39; flow scheduling systems.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span>
        
        <span class="n">eps</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">eps</span><span class="p">:</span>
            <span class="n">ep_queues</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ep</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ep_queue</span> <span class="ow">in</span> <span class="n">ep_queues</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">flow_dict</span> <span class="ow">in</span> <span class="n">ep_queue</span><span class="p">[</span><span class="s1">&#39;queued_flows&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;can_schedule&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># can&#39;t schedule, filter out of network</span>
                        <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_flow_from_queue</span><span class="p">(</span><span class="n">flow_dict</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># can schedule</span>
                        <span class="k">pass</span>
                        <span class="c1"># can schedule</span>
        
        <span class="c1"># check no bad flows left in queue</span>
        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">eps</span><span class="p">:</span>
            <span class="n">ep_queues</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ep</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ep_queue</span> <span class="ow">in</span> <span class="n">ep_queues</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">flow_dict</span> <span class="ow">in</span> <span class="n">ep_queue</span><span class="p">[</span><span class="s1">&#39;queued_flows&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;can_schedule&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Illegal flow(s) still present&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>

        
        
        <span class="k">return</span> <span class="n">net</span></div>
        
<div class="viewcode-block" id="SchedulerToolbox.reset_channel_capacities_of_edges"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.reset_channel_capacities_of_edges">[docs]</a>    <span class="k">def</span> <span class="nf">reset_channel_capacities_of_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Takes edges and resets their available capacities back to their maximum capacities.&#39;&#39;&#39;</span>
        <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">net</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">]:</span>
                <span class="c1"># reset channel capacity</span>
                <span class="n">init_chancap</span> <span class="o">=</span> <span class="n">net</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span>
                <span class="n">net</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;max_channel_capacity&#39;</span><span class="p">]</span>
                <span class="n">reset_chancap</span> <span class="o">=</span> <span class="n">net</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span>
        <span class="c1"># update global graph property</span>
        <span class="n">net</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;curr_nw_capacity_used&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>


        
<div class="viewcode-block" id="SchedulerToolbox.update_network_state"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.update_network_state">[docs]</a>    <span class="k">def</span> <span class="nf">update_network_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">hide_child_dependency_flows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reset_channel_capacities</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If hide_child_dependency_flows is True, will only update scheduler network</span>
<span class="sd">        to see flows that are ready to be scheduled i.e. all parent flow dependencies</span>
<span class="sd">        have been completed. This is used for &#39;job-agnostic&#39; scheduling systems</span>
<span class="sd">        which, rather than considering the job that each flow is part of, only consider</span>
<span class="sd">        the flow.</span>
<span class="sd">        </span>
<span class="sd">        If False, will just update network with all flows (even those that cannot yet</span>
<span class="sd">        be scheduled). This is used for &#39;job- &amp; network- aware&#39; scheduling systems.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">observation</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">reset_channel_capacities</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_channel_capacities_of_edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">hide_child_dependency_flows</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_unavailable_flows</span><span class="p">()</span></div>

            
            
            
    
<div class="viewcode-block" id="SchedulerToolbox.gen_flow_packets"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.gen_flow_packets">[docs]</a>    <span class="k">def</span> <span class="nf">gen_flow_packets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow_size</span><span class="p">):</span>
        <span class="n">num_packets</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">flow_size</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">packet_size</span><span class="p">)</span> <span class="c1"># round up </span>
        <span class="c1"># packets = [self.packet_size for _ in range(num_packets)]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_size</span><span class="p">,</span> <span class="n">num_packets</span></div>
    
<div class="viewcode-block" id="SchedulerToolbox.get_flow_from_network"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_flow_from_network">[docs]</a>    <span class="k">def</span> <span class="nf">get_flow_from_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">flow_idx</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given the server that the flow is at, the queue of the server that</span>
<span class="sd">        the flow is in, and the flow idx of the flow in the queue, this method</span>
<span class="sd">        returns the flow dict</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">server</span><span class="p">][</span><span class="n">queue</span><span class="p">][</span><span class="s1">&#39;queued_flows&#39;</span><span class="p">][</span><span class="n">flow_idx</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="c1"># flow being searched doesn&#39;t exist</span>
            <span class="k">return</span> <span class="s1">&#39;N/A&#39;</span></div>


<div class="viewcode-block" id="SchedulerToolbox.get_path_edges"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_path_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_path_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Takes a path and returns list of edges in the path</span>

<span class="sd">        Args:</span>
<span class="sd">        - path (list): path in which you want to find all edges</span>

<span class="sd">        Returns:</span>
<span class="sd">        - edges (list of lists): all edges contained within the path</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">num_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">num_edges</span> <span class="o">=</span> <span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="n">edge</span><span class="p">:</span><span class="n">edge</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_edges</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">edges</span></div>
    
<div class="viewcode-block" id="SchedulerToolbox.find_flow_idx"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.find_flow_idx">[docs]</a>    <span class="k">def</span> <span class="nf">find_flow_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">flows</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Finds flow idx in a list of flows. Assumes the following </span>
<span class="sd">        flow features are unique and unchanged properties of each flow:</span>
<span class="sd">        - flow size</span>
<span class="sd">        - source</span>
<span class="sd">        - destination</span>
<span class="sd">        - time arrived</span>

<span class="sd">        Args:</span>
<span class="sd">        - flow (dict): flow dictionary</span>
<span class="sd">        - flows (list of dicts) list of flows in which to find flow idx</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;dst&#39;</span><span class="p">]</span>
        <span class="n">time_arrived</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;time_arrived&#39;</span><span class="p">]</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">size</span> <span class="ow">and</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">src</span> <span class="ow">and</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;dst&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">dst</span> <span class="ow">and</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;time_arrived&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">time_arrived</span><span class="p">:</span>
                <span class="c1"># flow found in flows</span>
                <span class="k">return</span> <span class="n">idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># flow not found, move to next f in flows</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Flow not found in list of flows&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchedulerToolbox.find_flow_queue"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.find_flow_queue">[docs]</a>    <span class="k">def</span> <span class="nf">find_flow_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Finds queue of flow in network</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sn</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span>
        <span class="n">dn</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;dst&#39;</span><span class="p">]</span>
        <span class="n">flow_queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">sn</span><span class="p">][</span><span class="n">dn</span><span class="p">][</span><span class="s1">&#39;queued_flows&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">flow_queue</span></div>

<div class="viewcode-block" id="SchedulerToolbox.set_up_connection"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.set_up_connection">[docs]</a>    <span class="k">def</span> <span class="nf">set_up_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">num_decimals</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets up connection between src-dst node pair by removing capacity from</span>
<span class="sd">        all edges in path connecting them. Also updates graph&#39;s global curr </span>
<span class="sd">        network capacity used property</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        - flow (dict): flow dict containing flow info to set up</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_mode</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting up connection for flow </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flow</span><span class="p">))</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span>
        <span class="n">flow_size</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
        <span class="n">packet_size</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span>
        <span class="n">packets</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span>
        <span class="n">packets_this_slot</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packets_this_slot&#39;</span><span class="p">]</span>

        <span class="n">info_to_transfer_this_slot</span> <span class="o">=</span> <span class="n">packets_this_slot</span> <span class="o">*</span> <span class="n">packet_size</span>
        <span class="n">capacity_used_this_slot</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">info_to_transfer_this_slot</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span><span class="p">,</span> <span class="n">num_decimals</span><span class="p">)</span> <span class="c1"># info units of this flow transferred this time slot == capacity used on each channel in flow&#39;s path this time slot</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="n">num_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_edges</span><span class="p">):</span>
            <span class="n">node_pair</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
            <span class="c1"># update edge capacity remaining after establish this flow</span>
            <span class="n">init_bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">node_pair</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span> <span class="o">-=</span> <span class="n">capacity_used_this_slot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">],</span> <span class="n">num_decimals</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_mode</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Updated </span><span class="si">{}</span><span class="s1"> capacity for </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> -&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">node_pair</span><span class="p">,</span> <span class="n">init_bw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">node_pair</span><span class="p">,</span> <span class="n">channel</span><span class="p">)))</span>

            <span class="c1"># check that establishing this flow is valid given edge capacity constraints</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Tried to set up flow </span><span class="si">{}</span><span class="s1"> on edge </span><span class="si">{}</span><span class="s1"> channel </span><span class="si">{}</span><span class="s1">, but this results in a negative channel capacity on this edge i.e. this edge</span><span class="se">\&#39;</span><span class="s1">s channel is full, cannot have more flow packets scheduled!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">channel</span><span class="p">))</span> 

            <span class="c1"># update global graph property</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;curr_nw_capacity_used&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">capacity_used_this_slot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;num_active_connections&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="SchedulerToolbox.take_down_connection"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.take_down_connection">[docs]</a>    <span class="k">def</span> <span class="nf">take_down_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">num_decimals</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Removes established connection by adding capacity back onto all edges</span>
<span class="sd">        in the path connecting the src-dst node pair. Also updates graph&#39;s</span>
<span class="sd">        global curr network capacity used property</span>

<span class="sd">        Args:</span>
<span class="sd">        - flow (dict): flow dict containing info of flow to take down</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_mode</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Taking down connection for flow </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flow</span><span class="p">))</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span>
        <span class="n">flow_size</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
        <span class="n">packet_size</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span>
        <span class="n">packets</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span>
        <span class="n">packets_this_slot</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packets_this_slot&#39;</span><span class="p">]</span>

        <span class="n">info_to_transfer_this_slot</span> <span class="o">=</span> <span class="n">packets_this_slot</span> <span class="o">*</span> <span class="n">packet_size</span>
        <span class="n">capacity_used_this_slot</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">info_to_transfer_this_slot</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span><span class="p">,</span> <span class="n">num_decimals</span><span class="p">)</span> <span class="c1"># info units of this flow transferred this time slot == capacity used on each channel in flow&#39;s path this time slot</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        
        <span class="n">num_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_edges</span><span class="p">):</span>
            <span class="n">node_pair</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
            <span class="c1"># update edge property</span>
            <span class="n">init_bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">node_pair</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span> <span class="o">+=</span> <span class="n">capacity_used_this_slot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">node_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">],</span> <span class="n">num_decimals</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_mode</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Updated </span><span class="si">{}</span><span class="s1"> capacity for </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> -&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">node_pair</span><span class="p">,</span> <span class="n">init_bw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">node_pair</span><span class="p">,</span> <span class="n">channel</span><span class="p">)))</span>
            <span class="c1"># update global graph property</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;curr_nw_capacity_used&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="n">capacity_used_this_slot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;num_active_connections&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="SchedulerToolbox.get_channel_bandwidth"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_channel_bandwidth">[docs]</a>    <span class="k">def</span> <span class="nf">get_channel_bandwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Gets current channel bandwidth left on a given edge in the network.&#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">]</span></div>

<div class="viewcode-block" id="SchedulerToolbox.check_if_lightpath_available"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.check_if_lightpath_available">[docs]</a>    <span class="k">def</span> <span class="nf">check_if_lightpath_available</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">chosen_flows</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Checks if chosen flow already has edges which have been assigned to </span>
<span class="sd">        channel. If it does and if time_multiplexing, checks if any space left</span>
<span class="sd">        on contentious path channels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">taken_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">chosen_flows</span><span class="p">]</span>
        <span class="n">taken_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">chosen_flows</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">taken_path</span> <span class="ow">in</span> <span class="n">taken_paths</span><span class="p">:</span>
            <span class="n">taken_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">taken_path</span><span class="p">)</span>
            <span class="c1"># if any(e in taken_edges for e in edges) or any(e[::-1] in taken_edges for e in edges):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">taken_edges</span> <span class="ow">or</span> <span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">taken_edges</span><span class="p">:</span>
                    <span class="c1"># prev chosen paths contains 1 or more edges of curr chosen path</span>
                    <span class="c1"># check if taken path assigned to chosen channel</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">taken_paths</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">taken_path</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">:</span>
                        <span class="c1"># chosen channel already assigned to edge(s) in chosen path</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_multiplexing</span><span class="p">:</span>
                            <span class="c1"># can only have 1 flow per channel per edge, lightpath not available</span>
                            <span class="k">return</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># check if any bandwidth available</span>
                            <span class="n">available_bandwidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
                            <span class="c1"># _, max_packets_per_slot = self.get_max_flow_info_transferred_per_slot(chosen_flows[idx], path, channel)</span>
                            <span class="k">if</span> <span class="n">available_bandwidth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1"># can schedule</span>
                                <span class="k">return</span> <span class="kc">True</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># cannot schedule any more packets this time slot</span>
                                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>
    
<div class="viewcode-block" id="SchedulerToolbox.estimate_time_to_completion"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.estimate_time_to_completion">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_time_to_completion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow_dict</span><span class="p">):</span>
        <span class="c1"># num_packets = len(flow_dict[&#39;packets&#39;])</span>
        <span class="n">num_packets</span> <span class="o">=</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span>
        <span class="n">packet_size</span> <span class="o">=</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span>
        
        <span class="n">path_links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span>
        <span class="n">link_bws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">path_links</span><span class="p">:</span>
            <span class="n">link_bws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;max_channel_capacity&#39;</span><span class="p">])</span>
        <span class="n">lowest_bw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">link_bws</span><span class="p">)</span>
        
        <span class="n">size_per_slot</span> <span class="o">=</span> <span class="n">lowest_bw</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span><span class="p">)</span>
        <span class="n">packets_per_slot</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_per_slot</span> <span class="o">/</span> <span class="n">packet_size</span><span class="p">)</span> <span class="c1"># round down </span>
        <span class="k">if</span> <span class="n">packets_per_slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Encountered 0 packets that can be transferred per time slot. Either decrease packet size or increase time slot size.&#39;</span><span class="p">)</span>
        <span class="n">slots_to_completion</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_packets</span><span class="o">/</span><span class="n">packets_per_slot</span><span class="p">)</span> <span class="c1"># round up</span>
        <span class="n">completion_time</span> <span class="o">=</span> <span class="n">slots_to_completion</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span>
        
        <span class="k">return</span> <span class="n">completion_time</span><span class="p">,</span> <span class="n">packets_per_slot</span></div>

<div class="viewcode-block" id="SchedulerToolbox.binary_encode_time_in_queue"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.binary_encode_time_in_queue">[docs]</a>    <span class="k">def</span> <span class="nf">binary_encode_time_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_in_queue</span><span class="p">,</span> <span class="n">max_record_time_in_queue</span><span class="p">):</span>
        <span class="n">num_decimals</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">num_decimals</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                                                              <span class="n">max_record_time_in_queue</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span><span class="p">)]</span>
        <span class="n">time_to_int</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="n">binary_encoded_time_in_queue</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))]</span>
        
        <span class="n">round_to_nearest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">round_to_nearest</span>
        <span class="n">rounded_time_in_queue</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">time_in_queue</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="k">if</span> <span class="n">rounded_time_in_queue</span> <span class="o">&gt;</span> <span class="n">max_record_time_in_queue</span><span class="p">:</span>
            <span class="n">rounded_time_in_queue</span> <span class="o">=</span> <span class="n">max_record_time_in_queue</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">time_to_int</span><span class="p">[</span><span class="n">rounded_time_in_queue</span><span class="p">]</span>
        <span class="n">binary_encoded_time_in_queue</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">binary_encoded_time_in_queue</span></div>

    <span class="c1"># def binary_encode_num_packets(self, num_packets, max_record_num_packets):</span>
        <span class="c1"># binary_encoded_num_packets = [0 for _ in range(max_record_num_packets+1)]</span>
        <span class="c1"># if num_packets &gt; max_record_num_packets:</span>
            <span class="c1"># num_packets = num_packets</span>
        <span class="c1"># binary_encoded_num_packets[num_packets] = 1</span>
        
        <span class="c1"># return binary_encoded_num_packets</span>

<div class="viewcode-block" id="SchedulerToolbox.binary_encode_num_flows_in_queue"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.binary_encode_num_flows_in_queue">[docs]</a>    <span class="k">def</span> <span class="nf">binary_encode_num_flows_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_flows_in_queue</span><span class="p">,</span> <span class="n">max_num_flows_in_queue</span><span class="p">):</span>
        <span class="n">binary_encoded_num_flows</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_num_flows_in_queue</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">num_flows_in_queue</span> <span class="o">&gt;</span> <span class="n">max_num_flows_in_queue</span><span class="p">:</span>
            <span class="n">num_flows_in_queue</span> <span class="o">=</span> <span class="n">max_num_flows_in_queue</span>
        <span class="n">binary_encoded_num_flows</span><span class="p">[</span><span class="n">num_flows_in_queue</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">binary_encoded_num_flows</span></div>

<div class="viewcode-block" id="SchedulerToolbox.binary_encode_paths"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.binary_encode_paths">[docs]</a>    <span class="k">def</span> <span class="nf">binary_encode_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
        <span class="n">graph_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>

        <span class="c1"># map edges to integers</span>
        <span class="n">edge_to_int</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">))</span>
        <span class="n">int_to_edge</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">))</span>

        <span class="c1"># integer encode paths</span>
        <span class="n">int_encoded_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">path_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">path_edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">path_edges</span><span class="p">]</span>    
           
            <span class="n">encoded_path</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">path_edges</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">encoded_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_to_int</span><span class="p">[</span><span class="n">edge</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># undirected graph therefore can flip edge order</span>
                    <span class="n">encoded_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_to_int</span><span class="p">[</span><span class="n">edge</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            
            <span class="n">int_encoded_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encoded_path</span><span class="p">)</span>

        <span class="c1"># binary encode paths</span>
        <span class="n">binary_encoded_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">int_path</span> <span class="ow">in</span> <span class="n">int_encoded_paths</span><span class="p">:</span>
            <span class="n">binary_encoded_path</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">int_path</span><span class="p">:</span>
                <span class="n">binary_encoded_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">binary_encoded_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binary_encoded_path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">binary_encoded_paths</span></div>

<div class="viewcode-block" id="SchedulerToolbox.init_paths_and_packets"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.init_paths_and_packets">[docs]</a>    <span class="k">def</span> <span class="nf">init_paths_and_packets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow_dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;k_shortest_paths&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k_shortest_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RWA</span><span class="o">.</span><span class="n">k_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">,</span>
                                                         <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span>
                                                         <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;dst&#39;</span><span class="p">])</span>
            <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;k_shortest_paths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_shortest_paths</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># previously calculated and saved</span>
            <span class="k">pass</span>
        
        <span class="k">if</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">num_packets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_flow_packets</span><span class="p">(</span><span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">])</span>
            <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_packets</span>
            <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># previously calculated and saved</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">flow_dict</span></div>

<div class="viewcode-block" id="SchedulerToolbox.get_max_flow_info_transferred_per_slot"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_max_flow_info_transferred_per_slot">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_flow_info_transferred_per_slot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns maximum possible flow information &amp; number of packets transferred</span>
<span class="sd">        per timeslot given the flow&#39;s path (i.e. in point-to-point circuit switched</span>
<span class="sd">        network, max info transferred per slot is the bandwidth of the lowest bw</span>
<span class="sd">        link in the path * the slot size)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">packet_size</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span>
        <span class="n">path_links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">link_bws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">path_links</span><span class="p">:</span>
            <span class="n">link_bws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">channel</span><span class="p">))</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">link_bws</span><span class="p">)</span> <span class="c1"># channel capacity == info transferred per unit time</span>
        <span class="n">info_per_slot</span> <span class="o">=</span> <span class="n">capacity</span>  <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span> <span class="c1"># info transferred per slot == info transferred per unit time * number of time units (i.e. slot size)</span>
        <span class="n">packets_per_slot</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info_per_slot</span> <span class="o">/</span> <span class="n">packet_size</span><span class="p">)</span> <span class="c1"># round down </span>

        <span class="k">return</span> <span class="n">info_per_slot</span><span class="p">,</span> <span class="n">packets_per_slot</span></div>

<div class="viewcode-block" id="SchedulerToolbox.choose_num_packets_this_time_slot"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.choose_num_packets_this_time_slot">[docs]</a>    <span class="k">def</span> <span class="nf">choose_num_packets_this_time_slot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a flow, path and channel, finds the number of packets that this flow</span>
<span class="sd">        can have scheduled this time slot given the channel capacities of the link</span>
<span class="sd">        channels in the path.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">max_info_per_slot</span><span class="p">,</span> <span class="n">max_packets_per_slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_flow_info_transferred_per_slot</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_packets_per_slot</span> <span class="o">&gt;</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]:</span>
            <span class="c1"># fewer packets than maximum allowed per time slot, can schedule fewer packets</span>
            <span class="n">num_packets</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just schedule maximum packets this time slot</span>
            <span class="n">num_packets</span> <span class="o">=</span> <span class="n">max_packets_per_slot</span>
        <span class="k">return</span> <span class="n">num_packets</span></div>
        





<div class="viewcode-block" id="SchedulerToolbox.find_shortest_flow_in_queue"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.find_shortest_flow_in_queue">[docs]</a>    <span class="k">def</span> <span class="nf">find_shortest_flow_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queued_flows</span><span class="p">,</span> <span class="n">completion_times</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Allocates shortest lightpaths and finds flow in queue w/ shortest </span>
<span class="sd">        completion time</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">num_queued_flows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queued_flows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">flow_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_queued_flows</span><span class="p">):</span>
            <span class="n">flow_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_paths_and_packets</span><span class="p">(</span><span class="n">queued_flows</span><span class="p">[</span><span class="n">flow_idx</span><span class="p">])</span>
            <span class="c1">#shortest_paths = flow_dict[&#39;k_shortest_paths&#39;]</span>
            <span class="c1">#size = flow_dict[&#39;size&#39;]</span>
            <span class="c1">#path, _ = self.RWA.ff_k_shortest_paths(self.SchedulerNetwork,shortest_paths,size) </span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;k_shortest_paths&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RWA</span><span class="o">.</span><span class="n">channel_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
            <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span>
            <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packets_this_slot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_num_packets_this_time_slot</span><span class="p">(</span><span class="n">flow_dict</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="n">completion_time</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_time_to_completion</span><span class="p">(</span><span class="n">flow_dict</span><span class="p">)</span>
            <span class="n">completion_times</span><span class="p">[</span><span class="n">flow_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">completion_time</span>
        <span class="n">comp_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">completion_times</span><span class="p">)</span>
        <span class="n">active_flow_idx</span> <span class="o">=</span> <span class="n">completion_times</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">comp_time</span><span class="p">)</span>
        <span class="n">shortest_flow</span> <span class="o">=</span> <span class="n">queued_flows</span><span class="p">[</span><span class="n">active_flow_idx</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">shortest_flow</span><span class="p">,</span> <span class="n">comp_time</span></div>
    
<div class="viewcode-block" id="SchedulerToolbox.get_curr_queue_states"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_curr_queue_states">[docs]</a>    <span class="k">def</span> <span class="nf">get_curr_queue_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns all queues (empty and full) in network</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">]))</span> <span class="c1"># number of servers</span>
        <span class="n">num_queues</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">queues</span> <span class="o">=</span> <span class="p">{</span><span class="n">ep</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">]}</span>
        
        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">]:</span>
            <span class="n">ep_queues</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ep</span><span class="p">]</span>
            <span class="n">queues</span><span class="p">[</span><span class="n">ep</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep_queues</span>
        
        <span class="k">return</span> <span class="n">queues</span></div>

<div class="viewcode-block" id="SchedulerToolbox.look_for_available_lightpath"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.look_for_available_lightpath">[docs]</a>    <span class="k">def</span> <span class="nf">look_for_available_lightpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chosen_flow</span><span class="p">,</span> <span class="n">chosen_flows</span><span class="p">,</span> <span class="n">search_k_shortest</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If search_k_shortest, will look at all k shortest paths available</span>
<span class="sd">        in flow[&#39;k_shortest_paths&#39;]. If False, will only consider flow[&#39;path&#39;] </span>
<span class="sd">        already assigned.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># check for link contentions</span>
        <span class="k">if</span> <span class="n">search_k_shortest</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;k_shortest_paths&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]]</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RWA</span><span class="o">.</span><span class="n">channel_names</span>
        <span class="n">taken_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">chosen_flows</span><span class="p">]</span>
        <span class="n">taken_edges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">taken_path</span><span class="p">)</span> <span class="k">for</span> <span class="n">taken_path</span> <span class="ow">in</span> <span class="n">taken_paths</span><span class="p">]</span>
        <span class="n">taken_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">chosen_flows</span><span class="p">]</span>
        <span class="n">establish_flow</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">packets_this_slot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check if any lightpath available without needing to take down connection</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_if_lightpath_available</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">chosen_flows</span><span class="p">):</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">max_packets_per_slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_flow_info_transferred_per_slot</span><span class="p">(</span><span class="n">chosen_flow</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">max_packets_per_slot</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">establish_flow</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">packets_this_slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_num_packets_this_time_slot</span><span class="p">(</span><span class="n">chosen_flow</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">break</span>

        <span class="k">return</span> <span class="n">establish_flow</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">packets_this_slot</span></div>


<div class="viewcode-block" id="SchedulerToolbox.calc_basrpt_cost"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.calc_basrpt_cost">[docs]</a>    <span class="k">def</span> <span class="nf">calc_basrpt_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">flow_queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_flow_queue</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
        <span class="n">num_queued_flows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow_queue</span><span class="p">)</span>

        <span class="c1"># calc size of flow&#39;s queue</span>
        <span class="n">queue_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">flow_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_queued_flows</span><span class="p">):</span>
            <span class="n">flow_dict</span> <span class="o">=</span> <span class="n">flow_queue</span><span class="p">[</span><span class="n">flow_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">queued_flow_bytes</span> <span class="o">=</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">queued_flow_bytes</span> <span class="o">=</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span>
            <span class="n">queue_length</span> <span class="o">+=</span> <span class="n">queued_flow_bytes</span>

        <span class="c1"># calc flow fct</span>
        <span class="n">fct</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_time_to_completion</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>

        <span class="c1"># calc cost</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="p">((</span><span class="n">V</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">fct</span><span class="p">)</span> <span class="o">-</span> <span class="n">queue_length</span>

        <span class="k">return</span> <span class="n">cost</span></div>

<div class="viewcode-block" id="SchedulerToolbox.find_all_contending_flows"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.find_all_contending_flows">[docs]</a>    <span class="k">def</span> <span class="nf">find_all_contending_flows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chosen_flow</span><span class="p">,</span> <span class="n">chosen_flows</span><span class="p">,</span> <span class="n">cost_metric</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># check cost metric given is valid</span>
        <span class="k">if</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;basrpt_cost&#39;</span><span class="p">:</span>
            <span class="n">required_kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">required_kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> metric requires kwargs </span><span class="si">{}</span><span class="s1"> but have only given </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_metric</span><span class="p">,</span> <span class="n">required_kwargs</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
        
        


        <span class="n">contending_flows</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># &#39;prospective&#39; chosen flow params</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;k_shortest_paths&#39;</span><span class="p">]</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RWA</span><span class="o">.</span><span class="n">channel_names</span>
        
        <span class="c1"># &#39;already chosen&#39; flows params</span>
        <span class="n">taken_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">chosen_flows</span><span class="p">]</span>
        <span class="n">taken_edges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">taken_path</span><span class="p">)</span> <span class="k">for</span> <span class="n">taken_path</span> <span class="ow">in</span> <span class="n">taken_paths</span><span class="p">]</span>
        <span class="n">taken_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">chosen_flows</span><span class="p">]</span>

        <span class="c1"># find contention(s) between prospective chosen_flow and already chosen flows</span>
        <span class="c1"># i.e. find all already chosen flows whose established path and channel might possibly</span>
        <span class="c1"># contend with the prospective chosen flow&#39;s path and channel</span>
        <span class="n">found_contention</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">taken_paths</span><span class="p">)):</span>
                    <span class="n">taken_path_edges</span> <span class="o">=</span> <span class="n">taken_edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">taken_channel</span> <span class="o">=</span> <span class="n">taken_channels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">taken_channel</span> <span class="o">==</span> <span class="n">channel</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">taken_path_edges</span> <span class="ow">or</span> <span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">taken_path_edges</span><span class="p">:</span>
                                <span class="c1"># check if any bandwidth available on this edge channel</span>
                                <span class="n">available_bandwidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_multiplexing</span><span class="p">:</span>
                                    <span class="c1"># can have as many flows per channel per edge as bandwidth allows</span>
                                    <span class="k">if</span> <span class="n">available_bandwidth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="c1"># no more bandwidth on this channel, contention</span>
                                        <span class="n">found_contention</span><span class="o">=</span><span class="kc">True</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="c1"># can only have 1 flow per channel per edge</span>
                                    <span class="n">found_contention</span><span class="o">=</span><span class="kc">True</span>
                    <span class="k">if</span> <span class="n">found_contention</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">contending_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="c1"># have not yet encountered this channel, init channel dict -&gt; register contending flow</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;cont_f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;chosen_p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;chosen_c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;chosen_num_packets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;packets_this_slot&#39;</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;basrpt_cost&#39;</span><span class="p">:</span>
                                <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_basrpt_cost</span><span class="p">(</span><span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;fct&#39;</span><span class="p">:</span>
                                <span class="n">cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_time_to_completion</span><span class="p">(</span><span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;cost&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cost</span><span class="p">]</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># register contending flow</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;cont_f&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;chosen_p&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;chosen_c&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;chosen_num_packets&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;packets_this_slot&#39;</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;basrpt_cost&#39;</span><span class="p">:</span>
                                <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_basrpt_cost</span><span class="p">(</span><span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;fct&#39;</span><span class="p">:</span>
                                <span class="n">cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_time_to_completion</span><span class="p">(</span><span class="n">chosen_flows</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                            <span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;cost&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

                        <span class="n">found_contention</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># reset for next contention check</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contending_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Could not find where any contentions occurred&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">contending_flows</span></div>
        

<div class="viewcode-block" id="SchedulerToolbox.choose_channel_and_path_using_contending_flows"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.choose_channel_and_path_using_contending_flows">[docs]</a>    <span class="k">def</span> <span class="nf">choose_channel_and_path_using_contending_flows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contending_flows</span><span class="p">):</span>
        <span class="c1"># find initial guess for contending flow to choose a path and channel</span>
        <span class="c1"># find which channel has least contentious (highest cost) most contentious flow</span>
        <span class="c1"># -&gt; chosen flow will try to beat contending flows on this &#39;easiest to beat&#39; channel</span>
        <span class="n">highest_cost_by_channel</span> <span class="o">=</span> <span class="p">{</span><span class="n">channel</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">contending_flows</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;cost&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">contending_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">chosen_channel</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">highest_cost_by_channel</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">highest_cost_by_channel</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>

        <span class="c1"># find which of the contending flows for this channel is the most contentious (i.e. has lowest cost)</span>
        <span class="c1"># if chosen flow can beat this flow, it will beat all other flows on this channel and therefore should replace them all</span>
        <span class="n">idx_min_cost</span> <span class="o">=</span> <span class="n">contending_flows</span><span class="p">[</span><span class="n">chosen_channel</span><span class="p">][</span><span class="s1">&#39;cost&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">contending_flows</span><span class="p">[</span><span class="n">chosen_channel</span><span class="p">][</span><span class="s1">&#39;cost&#39;</span><span class="p">]))</span>
        <span class="n">contending_flow</span> <span class="o">=</span> <span class="n">contending_flows</span><span class="p">[</span><span class="n">chosen_channel</span><span class="p">][</span><span class="s1">&#39;cont_f&#39;</span><span class="p">][</span><span class="n">idx_min_cost</span><span class="p">]</span>
        <span class="n">contending_flow_cost</span> <span class="o">=</span> <span class="n">contending_flows</span><span class="p">[</span><span class="n">chosen_channel</span><span class="p">][</span><span class="s1">&#39;cost&#39;</span><span class="p">][</span><span class="n">idx_min_cost</span><span class="p">]</span>
        <span class="n">chosen_path</span> <span class="o">=</span> <span class="n">contending_flows</span><span class="p">[</span><span class="n">chosen_channel</span><span class="p">][</span><span class="s1">&#39;chosen_p&#39;</span><span class="p">][</span><span class="n">idx_min_cost</span><span class="p">]</span>

        <span class="c1"># group contending flows on chosen channel -&gt; these are the contending flows which</span>
        <span class="c1"># should be considered when determining whether chosen flow should be established</span>
        <span class="n">contending_flows_list</span> <span class="o">=</span> <span class="n">contending_flows</span><span class="p">[</span><span class="n">chosen_channel</span><span class="p">][</span><span class="s1">&#39;cont_f&#39;</span><span class="p">]</span>

        <span class="c1"># remove duplicate contending flows (since in above loop, added contending flow for each k path)</span>
        <span class="n">_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">contending_flows_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_list</span><span class="p">:</span>
                <span class="n">_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">contending_flows_list</span> <span class="o">=</span> <span class="n">_list</span>

        <span class="k">return</span> <span class="n">chosen_path</span><span class="p">,</span> <span class="n">chosen_channel</span><span class="p">,</span> <span class="n">contending_flow</span><span class="p">,</span> <span class="n">contending_flow_cost</span><span class="p">,</span> <span class="n">contending_flows_list</span></div>



<div class="viewcode-block" id="SchedulerToolbox.get_packets_available_if_drop_all_contending_flows"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_packets_available_if_drop_all_contending_flows">[docs]</a>    <span class="k">def</span> <span class="nf">get_packets_available_if_drop_all_contending_flows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chosen_flow</span><span class="p">,</span> <span class="n">chosen_path</span><span class="p">,</span> <span class="n">chosen_channel</span><span class="p">,</span> <span class="n">contending_flows_list</span><span class="p">):</span>
        <span class="c1"># if all contending packets dropped, find num packets that would be made available to the chosen flow</span>
        <span class="n">chosen_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">chosen_path</span><span class="p">)</span>
        <span class="n">chosen_edge_packets_available</span> <span class="o">=</span> <span class="p">{</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">):</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">chosen_channel</span><span class="p">))</span><span class="o">/</span><span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">chosen_edges</span><span class="p">}</span> <span class="c1"># track number of packets made available on each chosen path&#39;s edge were all contending flows to be dropped</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">contending_flows_list</span><span class="p">:</span>
            <span class="n">edges_freed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span> <span class="c1"># edges freed by dropping this contending flow</span>
            <span class="n">packets_freed</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="s1">&#39;packets_this_slot&#39;</span><span class="p">]</span> <span class="c1"># packets freed by dropping this contending flow</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_freed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chosen_edge_packets_available</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">chosen_edge_packets_available</span><span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">packets_freed</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">chosen_edge_packets_available</span><span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">packets_freed</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="c1"># this edge of contending flow is not in chosen flow&#39;s path, ignore</span>
                        <span class="k">pass</span>
        <span class="n">packets_freed</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">chosen_edge_packets_available</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">packets_freed</span></div>

<div class="viewcode-block" id="SchedulerToolbox.get_packets_available_outside_contending_edges"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_packets_available_outside_contending_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_packets_available_outside_contending_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chosen_flow</span><span class="p">,</span> <span class="n">chosen_path</span><span class="p">,</span> <span class="n">chosen_channel</span><span class="p">,</span> <span class="n">contending_flows_list</span><span class="p">):</span>
        <span class="c1"># # find number of packets available to chosen flow for any of the chosen path&#39;s edges which are not an edge of a contending flow</span>

        <span class="c1"># init list of contending flow edges</span>
        <span class="n">contending_flows_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">contending_flows_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]):</span>
                <span class="n">contending_flows_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="n">chosen_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">chosen_path</span><span class="p">)</span>
        <span class="n">edge_bws</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># track edge bandwidths outside contending flows</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">chosen_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">contending_flows_edges</span> <span class="ow">or</span> <span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">contending_flows_edges</span><span class="p">:</span>
                <span class="c1"># edge already considered w.r.t. at least one contending flow</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># edge not yet considered by only considering contending flows</span>
                <span class="n">edge_bws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">chosen_channel</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_bws</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># no other edges other than those in the contending flows need be considered when considering what the limiting available bandwidth is in the chosen path</span>
            <span class="n">lowest_packets_available_outside_contending_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lowest_bw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">edge_bws</span><span class="p">)</span>
            <span class="n">lowest_info_per_slot</span> <span class="o">=</span> <span class="n">lowest_bw</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span>
            <span class="n">lowest_packets_available_outside_contending_edges</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lowest_info_per_slot</span> <span class="o">/</span> <span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">lowest_packets_available_outside_contending_edges</span></div>

<div class="viewcode-block" id="SchedulerToolbox.get_maximum_packets_available_if_all_edges_empty"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_maximum_packets_available_if_all_edges_empty">[docs]</a>    <span class="k">def</span> <span class="nf">get_maximum_packets_available_if_all_edges_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chosen_flow</span><span class="p">,</span> <span class="n">chosen_path</span><span class="p">):</span>
        <span class="c1"># get lowest maximum channel capacity for chosen path edges -&gt; this is maximum possible rate of information for flow assuming all other contending flows dropped</span>
        <span class="n">max_chan_caps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">chosen_path</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;channels&#39;</span><span class="p">]:</span>
                <span class="n">max_chan_caps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SchedulerNetwork</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;max_channel_capacity&#39;</span><span class="p">])</span>
        <span class="n">max_chan_cap</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_chan_caps</span><span class="p">)</span>
        <span class="n">max_packets</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span> <span class="o">*</span> <span class="n">max_chan_cap</span><span class="p">)</span> <span class="o">/</span> <span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span> <span class="c1"># max poss num packets</span>

        <span class="k">return</span> <span class="n">max_packets</span></div>

<div class="viewcode-block" id="SchedulerToolbox.get_maximum_packets_requestable_by_flow"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.get_maximum_packets_requestable_by_flow">[docs]</a>    <span class="k">def</span> <span class="nf">get_maximum_packets_requestable_by_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chosen_flow</span><span class="p">,</span> <span class="n">max_packets_available_if_all_edges_empty</span><span class="p">,</span> <span class="n">packets_available_outside_contending_edges</span><span class="p">):</span>
        <span class="c1"># find max packets that chosen flow could possibly request on contending edges given 1. its size and 2. channel availability outside of the contending flows edges</span>
        <span class="k">if</span> <span class="n">packets_available_outside_contending_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no other edges other than contending flows edges need be considered, can request up to max packets (or just all remaining packets of flow)</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">],</span> <span class="n">max_packets_available_if_all_edges_empty</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># must also consider edges outside contending flows in determing maximum number of packets the flow can request on contending edges</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;packets&#39;</span><span class="p">],</span> <span class="n">packets_available_outside_contending_edges</span><span class="p">,</span> <span class="n">max_packets_available_if_all_edges_empty</span><span class="p">)</span></div>



<div class="viewcode-block" id="SchedulerToolbox.select_minimum_number_of_contending_flows_to_drop"><a class="viewcode-back" href="../../../../../trafpy.manager.src.schedulers.html#trafpy.manager.src.schedulers.schedulertoolbox.SchedulerToolbox.select_minimum_number_of_contending_flows_to_drop">[docs]</a>    <span class="k">def</span> <span class="nf">select_minimum_number_of_contending_flows_to_drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chosen_flow</span><span class="p">,</span> <span class="n">chosen_path</span><span class="p">,</span> <span class="n">chosen_channel</span><span class="p">,</span> <span class="n">contending_flows_list</span><span class="p">,</span> <span class="n">max_packets_requested_by_chosen_flow</span><span class="p">,</span> <span class="n">max_packets_available_if_all_edges_empty</span><span class="p">,</span> <span class="n">cost_metric</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># chosen flow cannot request the number of packets that would be freed up by dropping all found contending flows, do not need to drop all contending flow it would be inefficient to drop all flows, therefore should drop minimum number of</span>
        <span class="c1"># contentious flows needed until enough bandwidth is freed</span>
        <span class="c1"># check cost metric given is valid</span>
        <span class="k">if</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;basrpt_cost&#39;</span><span class="p">:</span>
            <span class="n">required_kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">required_kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> metric requires kwargs </span><span class="si">{}</span><span class="s1"> but have only given </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_metric</span><span class="p">,</span> <span class="n">required_kwargs</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># find flows which need to be dropped to free enough space</span>
        <span class="n">packets_available_if_drop_all_contending_flows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">contending_flows_corrected</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">chosen_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">chosen_path</span><span class="p">)</span>
        <span class="n">chosen_edge_packets_available</span> <span class="o">=</span> <span class="p">{</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">):</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slot_size</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_channel_bandwidth</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">chosen_channel</span><span class="p">))</span><span class="o">/</span><span class="n">chosen_flow</span><span class="p">[</span><span class="s1">&#39;packet_size&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">chosen_edges</span><span class="p">}</span>
        <span class="n">packets_freed_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># drop flows until have minimum amount bandwidth/packets needed</span>
            <span class="c1"># on all edges in chosen path</span>
            <span class="c1"># choose the least contentious (highest cost) flow to drop</span>
            <span class="k">if</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;basrpt_cost&#39;</span><span class="p">:</span>
                <span class="n">costs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_basrpt_cost</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">contending_flows_list</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;fct&#39;</span><span class="p">:</span>
                <span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">contending_flows_list</span><span class="p">:</span>
                    <span class="n">cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_time_to_completion</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

            <span class="n">idx_max_cost</span> <span class="o">=</span> <span class="n">costs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">costs</span><span class="p">))</span>
            <span class="n">contending_flows_corrected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contending_flows_list</span><span class="p">[</span><span class="n">idx_max_cost</span><span class="p">])</span>
            <span class="n">edges_freed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_edges</span><span class="p">(</span><span class="n">contending_flows_list</span><span class="p">[</span><span class="n">idx_max_cost</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">])</span>
            <span class="n">packets_freed</span> <span class="o">=</span> <span class="n">contending_flows_list</span><span class="p">[</span><span class="n">idx_max_cost</span><span class="p">][</span><span class="s1">&#39;packets_this_slot&#39;</span><span class="p">]</span>
            <span class="n">packets_available_if_drop_all_contending_flows</span> <span class="o">+=</span> <span class="n">packets_freed</span>
            <span class="n">packets_freed_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packets_freed</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_freed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chosen_edge_packets_available</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">chosen_edge_packets_available</span><span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">packets_freed</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">chosen_edge_packets_available</span><span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">packets_freed</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="c1"># this edge of contending flow is not in chosen flow&#39;s path, ignore</span>
                        <span class="k">pass</span>

            <span class="k">del</span> <span class="n">contending_flows_list</span><span class="p">[</span><span class="n">idx_max_cost</span><span class="p">]</span>
            <span class="c1"># print(&#39;Packets requested: {} | Packets freed: {} | chosen_edge_packets_available:\n{}&#39;.format(max_packets_requested_by_chosen_flow, packets_available_if_drop_all_contending_flows, chosen_edge_packets_available))</span>
            <span class="k">if</span> <span class="n">packets_available_if_drop_all_contending_flows</span> <span class="o">&gt;=</span> <span class="n">max_packets_requested_by_chosen_flow</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">chosen_edge_packets_available</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="n">max_packets_requested_by_chosen_flow</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
        
        <span class="c1"># update contending flows &amp; packets made available by dropping them</span>
        <span class="n">packets_scheduled_if_drop_all_contending_flows</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_packets_available_if_all_edges_empty</span><span class="p">,</span> <span class="n">packets_available_if_drop_all_contending_flows</span><span class="p">)</span>
        <span class="n">contending_flows_list</span> <span class="o">=</span> <span class="n">contending_flows_corrected</span>
        <span class="k">if</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;basrpt_cost&#39;</span><span class="p">:</span>
            <span class="n">costs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_basrpt_cost</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">contending_flows_list</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">cost_metric</span> <span class="o">==</span> <span class="s1">&#39;fct&#39;</span><span class="p">:</span>
            <span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">contending_flows_list</span><span class="p">:</span>
                <span class="n">cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_time_to_completion</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
        <span class="n">idx_min_cost</span> <span class="o">=</span> <span class="n">costs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">costs</span><span class="p">))</span>
        <span class="n">contending_flow</span> <span class="o">=</span> <span class="n">contending_flows_list</span><span class="p">[</span><span class="n">idx_min_cost</span><span class="p">]</span>
        <span class="n">contending_flow_cost</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">idx_min_cost</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">contending_flow</span><span class="p">,</span> <span class="n">contending_flow_cost</span><span class="p">,</span> <span class="n">contending_flows_list</span><span class="p">,</span> <span class="n">packets_scheduled_if_drop_all_contending_flows</span></div></div>





































</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Christopher W. F. Parsonson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>