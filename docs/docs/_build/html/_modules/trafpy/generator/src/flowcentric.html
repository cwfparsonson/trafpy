

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trafpy.generator.src.flowcentric &mdash; TrafPy 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> TrafPy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Contribute.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../License.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../setup.html">setup module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../trafpy.html">trafpy package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">TrafPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>trafpy.generator.src.flowcentric</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for trafpy.generator.src.flowcentric</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">trafpy.generator.src</span> <span class="kn">import</span> <span class="n">tools</span>
<span class="kn">from</span> <span class="nn">trafpy.generator.src.dists</span> <span class="kn">import</span> <span class="n">val_dists</span><span class="p">,</span> <span class="n">node_dists</span><span class="p">,</span> <span class="n">plot_dists</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span> <span class="c1"># use for initialising arbitrary length nested dict</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> <span class="c1"># progress bar</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">trange</span>
<span class="kn">from</span> <span class="nn">tqdm.contrib.concurrent</span> <span class="kn">import</span> <span class="n">process_map</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>






<div class="viewcode-block" id="FlowGenerator"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.FlowGenerator">[docs]</a><span class="k">class</span> <span class="nc">FlowGenerator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">eps</span><span class="p">,</span>
                 <span class="n">node_dist</span><span class="p">,</span>
                 <span class="n">flow_size_dist</span><span class="p">,</span>
                 <span class="n">interarrival_time_dist</span><span class="p">,</span>
                 <span class="n">network_load_config</span><span class="p">,</span>
                 <span class="n">min_num_demands</span><span class="o">=</span><span class="mi">6000</span><span class="p">,</span>
                 <span class="n">max_num_demands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">jensen_shannon_distance_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">min_last_demand_arrival_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">auto_node_dist_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">check_dont_exceed_one_ep_load</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">bidirectional_links</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">print_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            network_load_config (dict): Dict of form {&#39;network_rate_capacity&#39;: &lt;int/float&gt;, &#39;target_load_fraction&#39;: &lt;float&gt;, &#39;disable_timeouts&#39;: &lt;bool&gt;, &#39;return_new_interarrival_time_dist&#39;: &lt;bool&gt;},</span>
<span class="sd">                where network_rate_capacity is the maximum rate (in e.g. Gbps) at which</span>
<span class="sd">                information can be reliably transmitted over the communication network</span>
<span class="sd">                which the demand data will be inserted into, and where target_load_fraction</span>
<span class="sd">                is the fraction of the network rate capacity being requested by the demands</span>
<span class="sd">                (e.g. target_load_fraction=0.75 would generate demands which request</span>
<span class="sd">                a load that is 75% of the network rate capacity from the first to </span>
<span class="sd">                the last demand arriving). If &#39;target_load_fraction&#39; is None, won&#39;t adjust</span>
<span class="sd">                inter arrival time dist at all to meet network load.</span>
<span class="sd">            auto_node_dist_correction (bool): Set to True if you want TrafPy to</span>
<span class="sd">                automatically make invalid node distributions valid. If True, invalid</span>
<span class="sd">                node distributions where more load is being assigned to a end point</span>
<span class="sd">                link than the end point link has bandwidth will be changed by </span>
<span class="sd">                removing the invalid end point link load to its maximum 1.0 load</span>
<span class="sd">                and distributing the removed load across all other valid links</span>
<span class="sd">                uniformly.</span>
<span class="sd">            max_num_demands (int): If not None, will not exceed this number of demands,</span>
<span class="sd">                which can help if you find you are exceeding memory limitations in</span>
<span class="sd">                your simulations. However, this will also mean that the (1) jensen_shannon_distance_threshold</span>
<span class="sd">                and (2) min_last_demand_arrival_time you specifiy may not be met. To</span>
<span class="sd">                ensure these are met, you must set max_num_demands to None.</span>
<span class="sd">            jensen_shannon_distance_threshold (float): Maximum jensen shannon distance</span>
<span class="sd">                required of generated random variables w.r.t. discretised dist they&#39;re generated from.</span>
<span class="sd">                Must be between 0 and 1. Distance of 0 -&gt; distributions are exactly the same.</span>
<span class="sd">                Distance of 1 -&gt; distributions are not at all similar.</span>
<span class="sd">                https://medium.com/datalab-log/measuring-the-statistical-similarity-between-two-samples-using-jensen-shannon-and-kullback-leibler-8d05af514b15</span>
<span class="sd">                N.B. To meet threshold, this function will keep doubling num_demands</span>
<span class="sd">            check_dont_exceed_one_ep_load (bool): If True, when packing flows (assigning</span>
<span class="sd">                src-dst node pairs according to specified node distribution), will ensure</span>
<span class="sd">                that don&#39;t exceed 1.0 load on any end points. If this is not possible,</span>
<span class="sd">                will raise an Exception. If False, no exception will be raised, but run</span>
<span class="sd">                risk of exceeding 1.0 end point load, which for some users might be</span>
<span class="sd">                detrimental to their system.</span>
<span class="sd">            bidirectional_links (bool): If True, assume each network link is split</span>
<span class="sd">                into 2 ports; src port and dst port (i.e. the link is bidirectional).</span>
<span class="sd">                If False, treat network links as separate uni-directional links.</span>
<span class="sd">                In uni-directional case, will assume ep_link_capacity of network</span>
<span class="sd">                is for src OR dst link and pack by doubling ep_link_capacity and packing</span>
<span class="sd">                links with src-dst pairs. In bidirectional case,</span>
<span class="sd">                assume ep_link_capacity is for both src and dst ports, therefore no need</span>
<span class="sd">                to double and can pack links with src-dst pairs as they are.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span> <span class="o">=</span> <span class="n">node_dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_size_dist</span> <span class="o">=</span> <span class="n">flow_size_dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interarrival_time_dist</span> <span class="o">=</span> <span class="n">interarrival_time_dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span> <span class="o">=</span> <span class="n">min_num_demands</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span> <span class="o">=</span> <span class="n">max_num_demands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span> <span class="o">=</span> <span class="n">network_load_config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_last_demand_arrival_time</span> <span class="o">=</span> <span class="n">min_last_demand_arrival_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auto_node_dist_correction</span> <span class="o">=</span> <span class="n">auto_node_dist_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jensen_shannon_distance_threshold</span> <span class="o">=</span> <span class="n">jensen_shannon_distance_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_dont_exceed_one_ep_load</span> <span class="o">=</span> <span class="n">check_dont_exceed_one_ep_load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bidirectional_links</span> <span class="o">=</span> <span class="n">bidirectional_links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span> <span class="o">=</span> <span class="n">print_data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_pairs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_network_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;target_load_fraction&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;target_load_fraction&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.95</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Target load fraction </span><span class="si">{}</span><span class="s1"> is invalid. Must be &lt;= 0.95.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;target_load_fraction&#39;</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_dont_exceed_one_ep_load</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: check_dont_exceed_one_ep_load is set to False. This may result in end point loads going above 1.0, which for some users might be detrimental to the systems they want to test.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="FlowGenerator.create_flow_centric_demand_data"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.FlowGenerator.create_flow_centric_demand_data">[docs]</a>    <span class="k">def</span> <span class="nf">create_flow_centric_demand_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># flow sizes</span>
        <span class="n">flow_sizes</span> <span class="o">=</span> <span class="n">val_dists</span><span class="o">.</span><span class="n">gen_rand_vars_from_discretised_dist</span><span class="p">(</span><span class="n">unique_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_size_dist</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                                   <span class="n">probabilities</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_size_dist</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                                                                   <span class="n">num_demands</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span><span class="p">,</span>
                                                                   <span class="n">jensen_shannon_distance_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">jensen_shannon_distance_threshold</span><span class="p">)</span>
        <span class="c1"># update num_demands in case jensen-shannon distance threshold required num_demands to be increased</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span><span class="p">)</span>

        <span class="c1"># flow interarrival times</span>
        <span class="n">interarrival_times</span> <span class="o">=</span> <span class="n">val_dists</span><span class="o">.</span><span class="n">gen_rand_vars_from_discretised_dist</span><span class="p">(</span><span class="n">unique_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interarrival_time_dist</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                                           <span class="n">probabilities</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interarrival_time_dist</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                                                                           <span class="n">num_demands</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span><span class="p">,</span>
                                                                           <span class="n">jensen_shannon_distance_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">jensen_shannon_distance_threshold</span><span class="p">)</span>
        <span class="c1"># update num_demands in case jensen-shannon distance threshold required num_demands to be increased</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">interarrival_times</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">):</span>
            <span class="c1"># must sample flow sizes with updated num_demands</span>
            <span class="n">flow_sizes</span> <span class="o">=</span> <span class="n">val_dists</span><span class="o">.</span><span class="n">gen_rand_vars_from_discretised_dist</span><span class="p">(</span><span class="n">unique_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_size_dist</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                                       <span class="n">probabilities</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_size_dist</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                                                                       <span class="n">num_demands</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span><span class="p">,</span>
                                                                       <span class="n">jensen_shannon_distance_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;target_load_fraction&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># adjust overall interarrival time dist until overall load &lt;= user-specified load</span>
            <span class="n">interarrival_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_demand_load</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">,</span>
                                                          <span class="n">interarrival_times</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interarrival_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: max_num_demands is </span><span class="si">{}</span><span class="s1"> but needed </span><span class="si">{}</span><span class="s1"> flows to meet jensen_shannon_distance_threshold </span><span class="si">{}</span><span class="s1">. Capping num_demands to max_num_demands, therefore may not meet jensen_shannon_distance_threshold specified. Increase max_num_demands to ensure you meet the jensen_shannon_distance_threshold.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">jensen_shannon_distance_threshold</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span>

                <span class="c1"># sample flow sizes and interarrival times with max_num_demands</span>
                <span class="n">flow_sizes</span> <span class="o">=</span> <span class="n">val_dists</span><span class="o">.</span><span class="n">gen_rand_vars_from_discretised_dist</span><span class="p">(</span><span class="n">unique_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_size_dist</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                                           <span class="n">probabilities</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_size_dist</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                                                                           <span class="n">num_demands</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span><span class="p">,</span>
                                                                           <span class="n">jensen_shannon_distance_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">interarrival_times</span> <span class="o">=</span> <span class="n">val_dists</span><span class="o">.</span><span class="n">gen_rand_vars_from_discretised_dist</span><span class="p">(</span><span class="n">unique_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interarrival_time_dist</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                                                   <span class="n">probabilities</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interarrival_time_dist</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                                                                                   <span class="n">num_demands</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span><span class="p">,</span>
                                                                                   <span class="n">jensen_shannon_distance_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">jensen_shannon_distance_threshold</span><span class="p">)</span>
                <span class="c1"># adjust overall interarrival time dist until overall load &lt;= user-specified load</span>
                <span class="n">interarrival_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_demand_load</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">,</span>
                                                              <span class="n">interarrival_times</span><span class="p">)</span>


        <span class="c1"># corresponding flow event (arrival) times</span>
        <span class="n">event_times</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">gen_event_times</span><span class="p">(</span><span class="n">interarrival_times</span><span class="p">)</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">event_times_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">event_times</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">event_times</span><span class="p">)</span>

        <span class="c1"># flow ids</span>
        <span class="n">flow_ids</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;flow_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span><span class="p">)]</span>
        <span class="n">establish</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_demands</span><span class="p">)]</span>

        <span class="c1"># pack the flows into src-dst pairs to meet src-dst pair load config requirements of node_dist</span>
        <span class="n">packer</span> <span class="o">=</span> <span class="n">FlowPacker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">,</span>
                            <span class="n">flow_ids</span><span class="p">,</span>
                            <span class="n">flow_sizes</span><span class="p">,</span>
                            <span class="n">interarrival_times</span><span class="p">,</span>
                            <span class="n">network_load_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">,</span>
                            <span class="n">auto_node_dist_correction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">auto_node_dist_correction</span><span class="p">,</span>
                            <span class="n">check_dont_exceed_one_ep_load</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">check_dont_exceed_one_ep_load</span><span class="p">,</span>
                            <span class="n">bidirectional_links</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bidirectional_links</span><span class="p">)</span>
        <span class="n">packed_flows</span> <span class="o">=</span> <span class="n">packer</span><span class="o">.</span><span class="n">pack_the_flows</span><span class="p">()</span>

        <span class="c1"># compile packed flows into demand_data dict ordered in terms of arrival time</span>
        <span class="n">demand_data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;flow_id&#39;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s1">&#39;sn&#39;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s1">&#39;dn&#39;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s1">&#39;flow_size&#39;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s1">&#39;event_time&#39;</span><span class="p">:</span> <span class="n">event_times_sorted</span><span class="p">,</span>
                        <span class="s1">&#39;establish&#39;</span><span class="p">:</span> <span class="n">establish</span><span class="p">,</span>
                        <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">index</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">packed_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;src&#39;</span><span class="p">])</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;dst&#39;</span><span class="p">])</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_last_demand_arrival_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># duplicate flows until get duration &gt;= user-specified duration</span>
            <span class="n">adjustment_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_last_demand_arrival_time</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])</span>
            <span class="n">num_duplications</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">adjustment_factor</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_duplications</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARING: max_num_demands is </span><span class="si">{}</span><span class="s1"> but have specified min_last_demand_arrival_time </span><span class="si">{}</span><span class="s1">. Would need </span><span class="si">{}</span><span class="s1"> demands to reach this min_last_demand_arrival_time, therefore must increase max_num_demands (or set to None) if you want to meet this min_last_demand_arrival_time.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_num_demands</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_last_demand_arrival_time</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_duplications</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">])))</span>
                    <span class="k">return</span> <span class="n">demand_data</span>
            <span class="k">if</span> <span class="n">num_duplications</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># duplicate</span>
                <span class="n">demand_data</span> <span class="o">=</span> <span class="n">duplicate_demands_in_demand_data_dict</span><span class="p">(</span><span class="n">demand_data</span><span class="p">,</span> 
                                                                    <span class="n">num_duplications</span><span class="o">=</span><span class="n">num_duplications</span><span class="p">,</span>
                                                                    <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">demand_data</span></div>


    <span class="k">def</span> <span class="nf">_calc_overall_load_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow_sizes</span><span class="p">,</span> <span class="n">interarrival_times</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns load rate (info units per unit time).&#39;&#39;&#39;</span>
        <span class="n">info_arrived</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_total_info_arrived</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">)</span>
        <span class="n">first_flow_arrival_time</span><span class="p">,</span> <span class="n">last_flow_arrival_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_first_last_flow_arrival_times</span><span class="p">(</span><span class="n">interarrival_times</span><span class="p">)</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">last_flow_arrival_time</span> <span class="o">-</span> <span class="n">first_flow_arrival_time</span>
        <span class="k">return</span> <span class="n">info_arrived</span><span class="o">/</span><span class="n">duration</span>

    <span class="k">def</span> <span class="nf">_calc_total_info_arrived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow_sizes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_first_last_flow_arrival_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interarrival_times</span><span class="p">):</span>
        <span class="n">event_times</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">gen_event_times</span><span class="p">(</span><span class="n">interarrival_times</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">event_times</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">event_times</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_change_interarrival_times_by_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interarrival_times</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Updates self.interarrival_time_dist by a specified factor and returns new interarrival times.&#39;&#39;&#39;</span>
        <span class="n">new_interarrival_time_dist</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">rand_var</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interarrival_time_dist</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_rand_var</span> <span class="o">=</span> <span class="n">rand_var</span> <span class="o">*</span> <span class="n">factor</span>
            <span class="n">new_interarrival_time_dist</span><span class="p">[</span><span class="n">new_rand_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob</span>

        <span class="c1"># update interarrival time dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interarrival_time_dist</span> <span class="o">=</span> <span class="n">new_interarrival_time_dist</span>

        <span class="c1"># gen new interarrival times</span>
        <span class="c1"># NEW METHOD: Just scale interarrival times as you have scaled interarrival time dist</span>
        <span class="c1"># interarrival_times *= factor</span>
        <span class="n">interarrival_times</span> <span class="o">=</span> <span class="p">(</span><span class="n">interarrival_times</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>

        <span class="c1"># OLD METHOD: Re-generates by sampling from new dist. CON: Leads to different data -&gt; get different loads.</span>
        <span class="c1"># interarrival_times = val_dists.gen_rand_vars_from_discretised_dist(unique_vars=list(self.interarrival_time_dist.keys()),</span>
                                                                           <span class="c1"># probabilities=list(self.interarrival_time_dist.values()),</span>
                                                                           <span class="c1"># num_demands=self.num_demands)</span>

        <span class="k">return</span> <span class="n">interarrival_times</span>

    <span class="k">def</span> <span class="nf">_adjust_demand_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">flow_sizes</span><span class="p">,</span>
                            <span class="n">interarrival_times</span><span class="p">):</span>
        <span class="c1"># total info arriving (sum of flow sizes) is fixed</span>
        <span class="c1"># therefore to adjust load, must adjust duration by adjusting interarrival time dist</span>
        <span class="n">load_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_overall_load_rate</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">,</span> <span class="n">interarrival_times</span><span class="p">)</span>
        <span class="n">load_fraction</span> <span class="o">=</span> <span class="n">load_rate</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;network_rate_capacity&#39;</span><span class="p">]</span>
        <span class="n">adjustment_factor</span> <span class="o">=</span> <span class="n">load_fraction</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;target_load_fraction&#39;</span><span class="p">]</span> 
        <span class="n">interarrival_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_interarrival_times_by_factor</span><span class="p">(</span><span class="n">interarrival_times</span><span class="p">,</span> <span class="n">adjustment_factor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">interarrival_times</span></div>






<div class="viewcode-block" id="FlowPacker"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.FlowPacker">[docs]</a><span class="k">class</span> <span class="nc">FlowPacker</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">generator</span><span class="p">,</span>
                 <span class="n">eps</span><span class="p">,</span>
                 <span class="n">node_dist</span><span class="p">,</span>
                 <span class="n">flow_ids</span><span class="p">,</span>
                 <span class="n">flow_sizes</span><span class="p">,</span>
                 <span class="n">flow_interarrival_times</span><span class="p">,</span>
                 <span class="n">network_load_config</span><span class="p">,</span>
                 <span class="n">auto_node_dist_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">check_dont_exceed_one_ep_load</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">bidirectional_links</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">print_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            bidirectional_links (bool): If True, assume each network link is split</span>
<span class="sd">                into 2 ports; src port and dst port (i.e. the link is bidirectional).</span>
<span class="sd">                If False, treat network links as separate uni-directional links.</span>
<span class="sd">                In uni-directional case, will assume ep_link_capacity of network</span>
<span class="sd">                is for src OR dst link and pack by doubling ep_link_capacity and packing</span>
<span class="sd">                links with src-dst pairs. In bidirectional case,</span>
<span class="sd">                assume ep_link_capacity is for both src and dst ports, therefore no need</span>
<span class="sd">                to double and can pack links with src-dst pairs as they are.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">generator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">node_dist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_ids</span> <span class="o">=</span> <span class="n">flow_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_sizes</span> <span class="o">=</span> <span class="n">flow_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_interarrival_times</span> <span class="o">=</span> <span class="n">flow_interarrival_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span> <span class="o">=</span> <span class="n">network_load_config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auto_node_dist_correction</span> <span class="o">=</span> <span class="n">auto_node_dist_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_dont_exceed_one_ep_load</span> <span class="o">=</span> <span class="n">check_dont_exceed_one_ep_load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bidirectional_links</span> <span class="o">=</span> <span class="n">bidirectional_links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span> <span class="o">=</span> <span class="n">print_data</span>
        <span class="c1"># self.print_data = True # DEBUG</span>

        <span class="n">num_pairs</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_pairs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: </span><span class="si">{}</span><span class="s1"> endpoints have </span><span class="si">{}</span><span class="s1"> possible pairs, but packer has only been given </span><span class="si">{}</span><span class="s1"> flows to pack. This will result in sparse packing, which will limit how accurately the packer is able to replicate the target node distribution. If you do not want this, provide the packer with more flows (e.g. by setting min_num_demands to &gt; number of possible pairs).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">),</span> <span class="n">num_pairs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;target_load_fraction&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_node_dist_valid_for_this_load</span><span class="p">()</span>

<div class="viewcode-block" id="FlowPacker.reset"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.FlowPacker.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># init dict in which flows will be packed into src-dst pairs</span>
        <span class="n">nested_dict</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">nested_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span> <span class="o">=</span> <span class="n">nested_dict</span><span class="p">()</span>

        <span class="c1"># want to pack largest flows first -&gt; re-organise flows into descending order (will shuffle later so maintain random flow sizes of arrivals)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_sizes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_ids</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_ids</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                     <span class="s1">&#39;src&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                                     <span class="s1">&#39;dst&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># calc overall load rate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;target_load_fraction&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">_calc_overall_load_rate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_interarrival_times</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no particular target load specified, just assume max</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;network_rate_capacity&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Overall network load rate: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span><span class="p">))</span>

        <span class="c1"># calc target load rate of each src-dst pair</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_pairs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_network_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">all_combinations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_prob_dict</span> <span class="o">=</span> <span class="n">node_dists</span><span class="o">.</span><span class="n">get_pair_prob_dict_of_node_dist_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">all_combinations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># N.B. These values sum to 0.5 -&gt; need to allocate twice (src-dst and dst-src)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_target_load_rate_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">pair</span><span class="p">:</span> <span class="n">frac</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span> <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_prob_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>



        <span class="c1"># # calc target load rate for each ep</span>
        <span class="c1"># self.ep_target_load_rate_dict = {ep: 0 for ep in self.eps}</span>
        <span class="c1"># for pair in self.pair_target_load_rate_dict.keys():</span>
            <span class="c1"># self.ep_target_load_rate_dict[json.loads(pair)[0]] += self.pair_target_load_rate_dict[pair]</span>
            <span class="c1"># self.ep_target_load_rate_dict[json.loads(pair)[1]] += self.pair_target_load_rate_dict[pair]</span>

        <span class="c1"># calc target total info to pack into each src-dst pair</span>
        <span class="n">flow_event_times</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">gen_event_times</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_interarrival_times</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">flow_event_times</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">flow_event_times</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># set to some number to prevent infinities</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">1e6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_target_total_info_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">pair</span><span class="p">:</span> <span class="n">load_rate</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">load_rate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_target_load_rate_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># init current total info packed into each src-dst pair and current distance from target info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_current_total_info_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">pair</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_prob_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_current_distance_from_target_info_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">pair</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_target_total_info_dict</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_current_total_info_dict</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_prob_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

        <span class="c1"># calc max total info during simulation per end point and initialise end point total info tracker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_total_ep_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;ep_link_capacity&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bidirectional_links</span><span class="p">:</span>
            <span class="c1"># double total ep info so can pack src-dst pairs into links</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_total_ep_info</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="c1"># calc max info can put on src and dst ports (half ep dedicated to each so / 2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_total_port_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_total_ep_info</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span> <span class="o">=</span> <span class="p">{</span><span class="n">ep</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_total_infos</span> <span class="o">=</span> <span class="p">{</span><span class="n">ep</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dst_total_infos</span> <span class="o">=</span> <span class="p">{</span><span class="n">ep</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">}</span>

        <span class="n">flow_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pair prob dict:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_prob_dict</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pair target load rate dict:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_target_load_rate_dict</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pair target total info dict:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_target_total_info_dict</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;duration: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pair prob dict sum: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_prob_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pair target load rate sum: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_target_load_rate_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pair target total info sum: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_target_total_info_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max total ep info: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_total_ep_info</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sum of all flow sizes: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">)))</span></div>



<div class="viewcode-block" id="FlowPacker.pack_the_flows"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.FlowPacker.pack_the_flows">[docs]</a>    <span class="k">def</span> <span class="nf">pack_the_flows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If you find that your achieved node distribution does not look like</span>
<span class="sd">        your original node distribution before packing (e.g. achieved is more</span>
<span class="sd">        uniform), is probably because your flow sizes are very large for</span>
<span class="sd">        the end point bandwidth you have specified. Either decrease</span>
<span class="sd">        your flow sizes or increase the endpoint link capacity</span>
<span class="sd">        to make packing easier.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># packer_bar = ShadyBar(&#39;Packing flows &#39;, max=len(self.packed_flows.keys()))</span>
        <span class="c1"># packer_bar = ShadyBar(&#39;Packing flows &#39;, max=100)</span>
        <span class="c1"># printed_progress = {percent: False for percent in np.arange(0, 100, 1)}</span>
        <span class="c1"># prev_percent = 1</span>
        <span class="c1"># final_flow_count = len(self.flow_ids)</span>
        <span class="c1"># counter = 0</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> 
                    <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Packing flows&#39;</span><span class="p">,</span>
                    <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">smoothing</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_current_distance_from_target_info_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Packing flow </span><span class="si">{}</span><span class="s1"> of size </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]))</span>
            <span class="n">chosen_pair</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># randomly shuffle pair order to prevent unwanted fade trends in node dist</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
            <span class="c1"># get pair distances</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_current_distance_from_target_info_dict</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">])</span>
            <span class="c1"># sort in descending order</span>
            <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sorted_pairs</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">sorted_indices</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Current distance from target info:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sorted_pairs</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Looking for pair furthest from target info...&#39;</span><span class="p">)</span>

            <span class="c1"># first pass (try not to exceed target pair load)</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">sorted_pairs</span><span class="p">:</span>
                <span class="c1"># pair = pair[0]</span>
                <span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pair</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pair</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_dont_exceed_one_ep_load</span><span class="p">:</span>
                    <span class="c1"># ensure wont exceed 1.0 end point load by allocating this flow to pair</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_total_infos</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_total_port_info</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dst_total_infos</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_total_port_info</span><span class="p">:</span>
                        <span class="c1"># would exceed maximum load for at least one of src and/or dst</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_current_distance_from_target_info_dict</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># would exceed pair&#39;s target total info, try next pair</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">chosen_pair</span> <span class="o">=</span> <span class="n">pair</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># don&#39;t worry about exceeding 1.0 end point load, just allocate to pair furthest from target load</span>
                    <span class="n">chosen_pair</span> <span class="o">=</span> <span class="n">pair</span>
                    <span class="k">break</span>

            <span class="c1"># second pass (if can&#39;t avoid exceeding any pair&#39;s target load, pack into pair without exceeding max total load)</span>
            <span class="k">if</span> <span class="n">chosen_pair</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">sorted_pairs</span><span class="p">:</span>
                    <span class="c1"># pair = pair[0]</span>
                    <span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pair</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pair</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_dont_exceed_one_ep_load</span><span class="p">:</span>
                        <span class="c1"># ensure wont exceed 1.0 end point load by allocating this flow to pair</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_total_infos</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_total_port_info</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dst_total_infos</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_total_port_info</span><span class="p">:</span>
                            <span class="c1"># would exceed at least 1 of this pair&#39;s end point&#39;s maximum load by adding this flow, move to next pair</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">chosen_pair</span> <span class="o">=</span> <span class="n">pair</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># don&#39;t worry about exceeding 1.0 end point load, just allocate to pair furthest from target load</span>
                        <span class="n">chosen_pair</span> <span class="o">=</span> <span class="n">pair</span>
                        <span class="k">break</span>

            <span class="k">if</span> <span class="n">chosen_pair</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># could not find end point pair with enough capacity to take flow</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unable to find valid pair to assign flow </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> without exceeding ep total information load limit </span><span class="si">{}</span><span class="s1"> information units for this session. Decrease flow sizes to help with packing (recommended), and/or increase end point link capacity (recommended), and/or decrease your required target load to increase the time duration the flow packer has to pack flows into, and/or change your node dist to be less heavily skewed. Alternatively, try re-running dist and flow generator since may have chance of creating valid dists and flows which can be packed (also recommended). You can also disable this validity checker by setting check_dont_exceed_one_ep_load to False. Doing so will allow end point loads to go above 1.0 when packing the flows and disable this exception being raised. Current end point total information loads (information units):</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">Pair info distances from targets:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_total_ep_info</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_current_distance_from_target_info_dict</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning flow to pair </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chosen_pair</span><span class="p">))</span>

            <span class="c1"># pack flow into this pair</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pair_current_total_info_dict</span><span class="p">[</span><span class="n">chosen_pair</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_current_total_info_dict</span><span class="p">[</span><span class="n">chosen_pair</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pair_current_distance_from_target_info_dict</span><span class="p">[</span><span class="n">chosen_pair</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_current_distance_from_target_info_dict</span><span class="p">[</span><span class="n">chosen_pair</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]))</span>

            <span class="c1"># # DEBUG</span>
            <span class="c1"># if self.pair_current_distance_from_target_info_dict[chosen_pair] &lt; 0:</span>
                <span class="c1"># raise Exception()</span>

            <span class="c1"># updated packed flows dict</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">chosen_pair</span><span class="p">)</span>
            <span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;dst&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">src_total_infos</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dst_total_infos</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>

            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># counter += 1</span>
            <span class="c1"># percent = int((counter/final_flow_count)*100)</span>
            <span class="c1"># if percent != 100:</span>
                <span class="c1"># if percent % 1 == 0 and not printed_progress[percent]:</span>
                    <span class="c1"># packer_bar.next()</span>
                    <span class="c1"># printed_progress[percent] = True</span>
                    <span class="c1"># while prev_percent &lt; percent-1:</span>
                        <span class="c1"># # make bar catch up with current percent progress</span>
                        <span class="c1"># packer_bar.next()</span>
                        <span class="c1"># printed_progress[prev_percent+1] = True</span>
                        <span class="c1"># prev_percent += 1</span>
                    <span class="c1"># prev_percent = percent</span>


        <span class="c1"># shuffle flow order to maintain randomness</span>
        <span class="n">shuffled_packed_flows</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">shuffled_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffled_keys</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">shuffled_key</span> <span class="ow">in</span> <span class="n">shuffled_keys</span><span class="p">:</span>
            <span class="n">shuffled_packed_flows</span><span class="p">[</span><span class="n">shuffled_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="p">[</span><span class="n">shuffled_key</span><span class="p">]</span>

        <span class="c1"># # finish any incomplete bar</span>
        <span class="c1"># for percent in printed_progress.keys():</span>
            <span class="c1"># if not printed_progress[percent]:</span>
                <span class="c1"># packer_bar.next()</span>
        <span class="c1"># packer_bar.finish()</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Packed </span><span class="si">{}</span><span class="s1"> flows in </span><span class="si">{}</span><span class="s1"> s.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packed_flows</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Final total infos at each pair:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_current_total_info_dict</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final total infos at each ep:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span><span class="p">))</span>
            <span class="n">ep_load_rates</span> <span class="o">=</span> <span class="p">{</span><span class="n">ep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span><span class="p">[</span><span class="n">ep</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Corresponding final load rates at each ep:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ep_load_rates</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">shuffled_packed_flows</span></div>
            
    <span class="k">def</span> <span class="nf">_check_node_dist_valid_for_this_load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">endpoint_target_load_fraction_of_overall_load</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">endpoint_target_load_rate</span> <span class="o">=</span> <span class="n">endpoint_target_load_fraction_of_overall_load</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span>
            <span class="k">if</span> <span class="n">endpoint_target_load_rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;ep_link_capacity&#39;</span><span class="p">]:</span>
                <span class="c1"># target load rate is invalid</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_node_dist_correction</span><span class="p">:</span>
                    <span class="c1"># user has not enabled TrafPy automatic node distribution correction</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Your node distribution is invalid for your specified target load. Overall target network load rate: </span><span class="si">{}</span><span class="s1"> info units per unit time. Endpoint </span><span class="si">{}</span><span class="s1"> (node dist idx </span><span class="si">{}</span><span class="s1">) target fraction of this overall load: </span><span class="si">{}</span><span class="s1">. Therefore target load rate for this endpoint is </span><span class="si">{}</span><span class="s1"> info units per unit time, which is too high for this end point which has a maximum capacity of </span><span class="si">{}</span><span class="s1"> info units per unit time, therefore your specified node load distribution is invalid. Change your required src-dst target loads in node_dist, or decrease your specified overall load target, or set auto_node_dist_correction=True to make TrafPy automatically correct the node distribution for you by subtracting the excess load of the invalid endpoint and distribution this excess load amongst other nodes (i.e. as your requested network load tends to 1.0, all end point loads will also tend to 1.0).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">idx</span><span class="p">,</span> <span class="n">endpoint_target_load_fraction_of_overall_load</span><span class="p">,</span> <span class="n">endpoint_target_load_rate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;ep_link_capacity&#39;</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;auto_node_dist_correction set to True. Adjusting node distribution to make it valid...&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;init node dist before correction:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eps_at_capacity</span> <span class="o">=</span> <span class="p">{</span><span class="n">ep</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
                    <span class="n">invalid_ep_found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">while</span> <span class="n">invalid_ep_found</span><span class="p">:</span>
                        <span class="n">invalid_ep_found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_correct_node_dist</span><span class="p">()</span>
                    <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_auto_correct_node_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">max_ep_load_frac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;ep_link_capacity&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span> <span class="c1"># max fraction of total network load rate that one end point can take</span>
        <span class="n">excess_ep_load_rates</span> <span class="o">=</span> <span class="p">{</span><span class="n">ep</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ep_total_infos</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">invalid_ep_found</span> <span class="o">=</span> <span class="kc">False</span> 
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">endpoint_target_load_fraction_of_overall_load</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">endpoint_target_load_rate</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">endpoint_target_load_fraction_of_overall_load</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ep </span><span class="si">{}</span><span class="s1"> target load rate: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">endpoint_target_load_rate</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">endpoint_target_load_rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;ep_link_capacity&#39;</span><span class="p">]:</span>
                <span class="c1"># too much load rate on this ep</span>
                <span class="n">invalid_ep_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">excess_ep_load_rates</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">endpoint_target_load_rate</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_load_config</span><span class="p">[</span><span class="s1">&#39;ep_link_capacity&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eps_at_capacity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># make ep loads equal on all this ep&#39;s pairs such that max ep bandwidth requested</span>
                <span class="k">for</span> <span class="n">pair_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">pair_idx</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">pair_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_ep_load_frac</span> <span class="o">/</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">[</span><span class="n">pair_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_ep_load_frac</span> <span class="o">/</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
                <span class="c1"># spread excess load evenly across other eps not already at capacity</span>
                <span class="n">free_eps</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">excess_ep_load_rates</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_at_capacity</span><span class="p">[</span><span class="n">ep</span><span class="p">]:</span>
                        <span class="n">free_eps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_eps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No free end points left to spread excess load across.&#39;</span><span class="p">)</span>
                <span class="n">load_rate_to_spread_per_ep</span> <span class="o">=</span> <span class="n">excess_ep_load_rates</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_eps</span><span class="p">)</span>
                <span class="n">frac_load_rate_to_spread_per_ep</span> <span class="o">=</span> <span class="n">load_rate_to_spread_per_ep</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span>
                <span class="n">frac_load_rate_to_spread_per_ep_pair</span> <span class="o">=</span> <span class="n">frac_load_rate_to_spread_per_ep</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">free_eps</span><span class="p">)</span> <span class="c1"># shuffle so not always spreading load across same eps</span>
                <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">free_eps</span><span class="p">:</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_index</span><span class="p">[</span><span class="n">ep</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_at_capacity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index_to_node</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_to_index</span><span class="p">[</span><span class="n">ep</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">frac_load_rate_to_spread_per_ep_pair</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_index</span><span class="p">[</span><span class="n">ep</span><span class="p">]]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">frac_load_rate_to_spread_per_ep_pair</span><span class="p">)</span>

                <span class="n">endpoint_target_load_fraction_of_overall_load</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">endpoint_target_load_rate</span> <span class="o">=</span> <span class="n">endpoint_target_load_fraction_of_overall_load</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_rate</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span> <span class="c1"># update params</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_data</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;updated node dist:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_dist</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">invalid_ep_found</span></div>
















        

        












<span class="c1"># FUNCTIONS</span>

<div class="viewcode-block" id="get_flow_centric_demand_data_ep_load_rate"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.get_flow_centric_demand_data_ep_load_rate">[docs]</a><span class="k">def</span> <span class="nf">get_flow_centric_demand_data_ep_load_rate</span><span class="p">(</span><span class="n">demand_data</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;all_eps&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    If method==&#39;all_eps&#39;, duration is time_last_flow_arrived-time_first_flow_arrived</span>
<span class="sd">    across all endpoints. If method==&#39;per_ep&#39;, duration is time_last_flow_arrived-time_first_flow_arrived</span>
<span class="sd">    for this specific ep.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ep_info</span> <span class="o">=</span> <span class="n">group_demand_data_into_ep_info</span><span class="p">(</span><span class="n">demand_data</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">total_info</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ep_info</span><span class="p">[</span><span class="n">ep</span><span class="p">][</span><span class="s1">&#39;flow_size&#39;</span><span class="p">])</span>
    <span class="c1"># if method == &#39;per_ep&#39;:</span>
        <span class="c1"># time_first_flow_arrived = min(ep_info[ep][&#39;event_time&#39;])</span>
        <span class="c1"># time_last_flow_arrived = max(ep_info[ep][&#39;event_time&#39;])</span>
    <span class="c1"># if method == &#39;all_eps&#39;:</span>
    <span class="n">time_first_flow_arrived</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])</span>
    <span class="n">time_last_flow_arrived</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="n">time_last_flow_arrived</span> <span class="o">-</span> <span class="n">time_first_flow_arrived</span>
    <span class="k">if</span> <span class="n">duration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">load_rate</span> <span class="o">=</span> <span class="n">total_info</span> <span class="o">/</span> <span class="n">duration</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">load_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">load_rate</span></div>

<div class="viewcode-block" id="get_flow_centric_demand_data_overall_load_rate"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.get_flow_centric_demand_data_overall_load_rate">[docs]</a><span class="k">def</span> <span class="nf">get_flow_centric_demand_data_overall_load_rate</span><span class="p">(</span><span class="n">demand_data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    If flow connections are bidirectional_links, 1 flow takes up 2 endpoint links (the</span>
<span class="sd">    source link and the destination link), therefore effecitvely takes up load rate</span>
<span class="sd">    2*flow_size*duration bandwidth. If not bidriectional, only takes up</span>
<span class="sd">    1*flow_size*duration since only occupies bandwidth for 1 of these links.</span>

<span class="sd">    If method == &#39;mean_per_ep&#39;, will calculate the total network load as being the mean</span>
<span class="sd">    average load on each endpoint link (i.e. sum info requests for each link -&gt;</span>
<span class="sd">    find load of each link -&gt; find mean of ep link loads)</span>

<span class="sd">    If method == &#39;mean_all_eps&#39;, will calculate the total network load as being</span>
<span class="sd">    the average load over all endpoint links (i.e. sum info requests for all links</span>
<span class="sd">    -&gt; find overall load of network)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">info_arrived</span> <span class="o">=</span> <span class="n">get_flow_centric_demand_data_total_info_arrived</span><span class="p">(</span><span class="n">demand_data</span><span class="p">)</span>
    <span class="n">first_event_time</span><span class="p">,</span> <span class="n">last_event_time</span> <span class="o">=</span> <span class="n">get_first_last_flow_arrival_times</span><span class="p">(</span><span class="n">demand_data</span><span class="p">)</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="n">last_event_time</span> <span class="o">-</span> <span class="n">first_event_time</span>

    <span class="k">if</span> <span class="n">duration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">load_rate</span> <span class="o">=</span> <span class="n">info_arrived</span><span class="o">/</span><span class="n">duration</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">load_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">load_rate</span></div>



<div class="viewcode-block" id="group_demand_data_into_ep_info"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.group_demand_data_into_ep_info">[docs]</a><span class="k">def</span> <span class="nf">group_demand_data_into_ep_info</span><span class="p">(</span><span class="n">demand_data</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
    <span class="n">nested_dict</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">nested_dict</span><span class="p">)</span>
    <span class="n">ep_info</span> <span class="o">=</span> <span class="n">nested_dict</span><span class="p">()</span>
    <span class="n">added_flow</span> <span class="o">=</span> <span class="p">{</span><span class="n">flow_id</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">flow_id</span> <span class="ow">in</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">]}</span>
    <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">eps</span><span class="p">:</span>
        <span class="n">ep_info</span><span class="p">[</span><span class="n">ep</span><span class="p">][</span><span class="s1">&#39;flow_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># ep_info[ep][&#39;event_time&#39;] = []</span>
        <span class="n">ep_info</span><span class="p">[</span><span class="n">ep</span><span class="p">][</span><span class="s1">&#39;demand_data_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ep_info</span><span class="p">[</span><span class="n">ep</span><span class="p">][</span><span class="s1">&#39;flow_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># ep_info[ep][&#39;establish&#39;] = []</span>
        <span class="c1"># ep_info[ep][&#39;index&#39;] = []</span>
        <span class="n">ep_info</span><span class="p">[</span><span class="n">ep</span><span class="p">][</span><span class="s1">&#39;sn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ep_info</span><span class="p">[</span><span class="n">ep</span><span class="p">][</span><span class="s1">&#39;dn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># group demand data by ep</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">])):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">added_flow</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]]:</span> 
            <span class="c1"># not yet added this flow</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;flow_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;flow_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
            <span class="c1"># ep_info[demand_data[&#39;sn&#39;][idx]][&#39;event_time&#39;].append(demand_data[&#39;event_time&#39;][idx])</span>
            <span class="c1"># ep_info[demand_data[&#39;dn&#39;][idx]][&#39;event_time&#39;].append(demand_data[&#39;event_time&#39;][idx])</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;demand_data_idx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;demand_data_idx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;flow_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;flow_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
            <span class="c1"># ep_info[demand_data[&#39;sn&#39;][idx]][&#39;establish&#39;].append(demand_data[&#39;establish&#39;][idx])</span>
            <span class="c1"># ep_info[demand_data[&#39;dn&#39;][idx]][&#39;establish&#39;].append(demand_data[&#39;establish&#39;][idx])</span>
            <span class="c1"># ep_info[demand_data[&#39;sn&#39;][idx]][&#39;index&#39;].append(demand_data[&#39;index&#39;][idx])</span>
            <span class="c1"># ep_info[demand_data[&#39;dn&#39;][idx]][&#39;index&#39;].append(demand_data[&#39;index&#39;][idx])</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;sn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;dn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;sn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">ep_info</span><span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]][</span><span class="s1">&#39;dn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># already added this flow</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">ep_info</span></div>


<div class="viewcode-block" id="get_flow_centric_demand_data_total_info_arrived"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.get_flow_centric_demand_data_total_info_arrived">[docs]</a><span class="k">def</span> <span class="nf">get_flow_centric_demand_data_total_info_arrived</span><span class="p">(</span><span class="n">demand_data</span><span class="p">):</span> 
    <span class="n">info_arrived</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># print(&#39;flow size {} {}&#39;.format(type(demand_data[&#39;flow_size&#39;]), type(demand_data[&#39;flow_size&#39;][0])))</span>
    <span class="c1"># if &#39;job_id&#39; in demand_data:</span>
        <span class="c1"># # jobcentric</span>
        <span class="c1"># flow_data = demand_data[&#39;flow_data&#39;]</span>
    <span class="c1"># else:</span>
        <span class="c1"># # flowcentric</span>
        <span class="c1"># flow_data = demand_data</span>

    <span class="k">for</span> <span class="n">flow_size</span> <span class="ow">in</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">flow_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">info_arrived</span> <span class="o">+=</span> <span class="n">flow_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
    
    <span class="k">return</span> <span class="n">info_arrived</span></div>
            
<div class="viewcode-block" id="get_first_last_flow_arrival_times"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.get_first_last_flow_arrival_times">[docs]</a><span class="k">def</span> <span class="nf">get_first_last_flow_arrival_times</span><span class="p">(</span><span class="n">demand_data</span><span class="p">):</span>
    <span class="n">arrival_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]:</span>
            <span class="n">arrival_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrival_times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Could not find first event establish request with size &gt; 0.. This occurs because either demand_data given does not contain any events, or because all events have had to be dropped to try get below your specified target load. Try increasing the target load or increasing the granularity of load per demand (by e.g. decreasing demand sizes, increasing total number of demands, etc.) when you generate your demand data so that this function can more easily hit your desired load target.&#39;</span><span class="p">)</span>

    <span class="n">time_first_flow_arrived</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">arrival_times</span><span class="p">)</span>
    <span class="n">time_last_flow_arrived</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arrival_times</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">time_first_flow_arrived</span><span class="p">,</span> <span class="n">time_last_flow_arrived</span></div>



<div class="viewcode-block" id="duplicate_demands_in_demand_data_dict"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.duplicate_demands_in_demand_data_dict">[docs]</a><span class="k">def</span> <span class="nf">duplicate_demands_in_demand_data_dict</span><span class="p">(</span><span class="n">demand_data</span><span class="p">,</span> <span class="n">num_duplications</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Duplicates set of demands by the specified number of times.&#39;&#39;&#39;</span>
    <span class="n">demand_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">demand_data</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;use_multiprocessing&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;use_multiprocessing&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="s1">&#39;num_processes&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="c1"># increase to decrease processing time, decrease to decrease risk of memory errors</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num_processes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># num processes to run in parallel if multiprocessing</span>
    <span class="k">if</span> <span class="s1">&#39;maxtasksperchild&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;maxtasksperchild&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># num tasks per process</span>
    
    <span class="k">if</span> <span class="s1">&#39;job_id&#39;</span> <span class="ow">in</span> <span class="n">demand_data</span><span class="p">:</span>
        <span class="n">job_centric</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">job_centric</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># ensure values of dict are lists</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">demand_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">demand_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">init_num_demands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])</span>
    <span class="n">demands_to_add</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">num_duplications</span><span class="p">)</span><span class="o">*</span><span class="n">init_num_demands</span><span class="p">)</span> <span class="o">-</span> <span class="n">init_num_demands</span>

    <span class="c1"># progress bar</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;use_multiprocessing&#39;</span><span class="p">]:</span>
        <span class="c1"># TODO: Get progress bar working for multiprocessing</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">demands_to_add</span><span class="p">,</span> 
                <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Duplicating demands&#39;</span><span class="p">,</span>
                    <span class="n">miniters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                    <span class="c1"># mininterval=1,</span>
                    <span class="c1"># maxinterval=1, # 2</span>
                    <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">smoothing</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span> <span class="c1"># 1</span>
    <span class="c1"># pbar = tqdm(total=demands_to_add, </span>
            <span class="c1"># desc=&#39;Duplicating demands&#39;,</span>
            <span class="c1"># miniters=1)</span>
                <span class="c1"># # mininterval=1,</span>
                <span class="c1"># # maxinterval=1, # 2</span>
                <span class="c1"># # leave=False,</span>
                <span class="c1"># # smoothing=1e-5) # 1</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dup</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_duplications</span><span class="p">):</span>

        <span class="c1"># get curr num demands</span>
        <span class="n">num_demands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])</span>

        <span class="c1"># get curr duration</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])</span> 

        <span class="c1"># duplicate demands</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;use_multiprocessing&#39;</span><span class="p">]:</span>
            <span class="c1"># duplicate demands in parallel</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Duplication </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1">...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dup</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_duplications</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="c1"># init shared lists for appending duplicated demands to</span>
            <span class="n">jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="n">job_ids</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="c1"># unique_ids = multiprocessing.Manager().list()</span>
            <span class="n">flow_ids</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="n">sns</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="n">dns</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="n">flow_sizes</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="n">event_times</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="n">establishes</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

            <span class="c1"># for idx in trange(num_demands): </span>
                <span class="c1"># results = process_map(duplicate_demand,</span>
                                            <span class="c1"># [demand_data[&#39;job&#39;][idx], </span>
                                            <span class="c1"># demand_data[&#39;sn&#39;][idx],</span>
                                            <span class="c1"># demand_data[&#39;dn&#39;][idx],</span>
                                            <span class="c1"># demand_data[&#39;flow_size&#39;][idx],</span>
                                            <span class="c1"># demand_data[&#39;event_time&#39;][idx],</span>
                                            <span class="c1"># duration,</span>
                                            <span class="c1"># demand_data[&#39;establish&#39;][idx],</span>
                                            <span class="c1"># demand_data[&#39;index&#39;][idx],</span>
                                            <span class="c1"># num_demands,</span>
                                            <span class="c1"># idx, </span>
                                            <span class="c1"># jobs, </span>
                                            <span class="c1"># job_ids,</span>
                                            <span class="c1"># unique_ids,</span>
                                            <span class="c1"># flow_ids,</span>
                                            <span class="c1"># sns,</span>
                                            <span class="c1"># dns,</span>
                                            <span class="c1"># flow_sizes,</span>
                                            <span class="c1"># event_times,</span>
                                            <span class="c1"># establishes,</span>
                                            <span class="c1"># indexes,</span>
                                            <span class="c1"># job_centric])</span>
            <span class="c1"># duplicate demands in parallel</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num_processes&#39;</span><span class="p">],</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;maxtasksperchild&#39;</span><span class="p">])</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">duplicate_demand</span><span class="p">,</span>
                                        <span class="n">args</span><span class="o">=</span><span class="p">(</span>
                                        <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;job&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> 
                                        <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                        <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                        <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                        <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                        <span class="n">duration</span><span class="p">,</span>
                                        <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;establish&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                        <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                        <span class="n">num_demands</span><span class="p">,</span>
                                        <span class="n">idx</span><span class="p">,</span> 
                                        <span class="n">jobs</span><span class="p">,</span> 
                                        <span class="n">job_ids</span><span class="p">,</span>
                                        <span class="c1"># unique_ids,</span>
                                        <span class="n">flow_ids</span><span class="p">,</span>
                                        <span class="n">sns</span><span class="p">,</span>
                                        <span class="n">dns</span><span class="p">,</span>
                                        <span class="n">flow_sizes</span><span class="p">,</span>
                                        <span class="n">event_times</span><span class="p">,</span>
                                        <span class="n">establishes</span><span class="p">,</span>
                                        <span class="n">indexes</span><span class="p">,</span>
                                        <span class="n">job_centric</span><span class="p">))</span>
                                       <span class="c1"># callback=lambda _: pbar.update(1))</span>
                                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_demands</span><span class="p">)]</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">pool</span>

            <span class="c1"># collect duplicated demands from multiprocessing and add to demand_data</span>
            <span class="k">if</span> <span class="n">job_centric</span><span class="p">:</span>
                <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;job_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">job_ids</span><span class="p">))</span>
                <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;job&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">jobs</span><span class="p">))</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">flow_ids</span><span class="p">))</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sns</span><span class="p">))</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dns</span><span class="p">))</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">flow_sizes</span><span class="p">))</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">event_times</span><span class="p">))</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;establish&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">establishes</span><span class="p">))</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indexes</span><span class="p">))</span>

            <span class="n">e</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Duplication completed in </span><span class="si">{}</span><span class="s1"> s.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="n">s</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># not multiprocessing -&gt; duplicate demands sequentially</span>
            <span class="c1"># no need to init separate lists since can append directly</span>
            <span class="k">if</span> <span class="n">job_centric</span><span class="p">:</span>
                <span class="n">jobs</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;job&#39;</span><span class="p">]</span>
                <span class="n">job_ids</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;job_id&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">jobs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">job_ids</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># unique_ids = []</span>
            <span class="n">flow_ids</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">]</span>
            <span class="n">sns</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">]</span>
            <span class="n">dns</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">]</span>
            <span class="n">flow_sizes</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">]</span>
            <span class="n">event_times</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">]</span>
            <span class="n">establishes</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;establish&#39;</span><span class="p">]</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">job_centric</span><span class="p">:</span>
                <span class="n">demand</span> <span class="o">=</span> <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;job&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">demand</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># don&#39;t need</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_demands</span><span class="p">):</span>
                <span class="n">duplicate_demand</span><span class="p">(</span><span class="n">demand</span><span class="p">,</span> 
                                 <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                 <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                 <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                 <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                 <span class="n">duration</span><span class="p">,</span>
                                 <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;establish&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                 <span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                                 <span class="n">num_demands</span><span class="p">,</span>
                                 <span class="n">idx</span><span class="p">,</span> 
                                 <span class="n">jobs</span><span class="p">,</span> 
                                 <span class="n">job_ids</span><span class="p">,</span>
                                 <span class="c1"># unique_ids,</span>
                                 <span class="n">flow_ids</span><span class="p">,</span>
                                 <span class="n">sns</span><span class="p">,</span>
                                 <span class="n">dns</span><span class="p">,</span>
                                 <span class="n">flow_sizes</span><span class="p">,</span>
                                 <span class="n">event_times</span><span class="p">,</span>
                                 <span class="n">establishes</span><span class="p">,</span>
                                 <span class="n">indexes</span><span class="p">,</span>
                                 <span class="n">job_centric</span><span class="p">)</span>

                <span class="c1"># # collect duplicated demands and add to demand_data</span>
                <span class="c1"># if job_centric:</span>
                    <span class="c1"># demand_data[&#39;job_id&#39;].extend(list(job_ids))</span>
                    <span class="c1"># demand_data[&#39;job&#39;].extend(list(jobs))</span>
                <span class="c1"># demand_data[&#39;flow_id&#39;].extend(list(flow_ids))</span>
                <span class="c1"># demand_data[&#39;sn&#39;].extend(list(sns))</span>
                <span class="c1"># demand_data[&#39;dn&#39;].extend(list(dns))</span>
                <span class="c1"># demand_data[&#39;flow_size&#39;].extend(list(flow_sizes))</span>
                <span class="c1"># demand_data[&#39;event_time&#39;].extend(list(event_times))</span>
                <span class="c1"># demand_data[&#39;establish&#39;].extend(list(establishes))</span>
                <span class="c1"># demand_data[&#39;index&#39;].extend(list(indexes))</span>

                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># make sure demand data still ordered in order of event time</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">demand_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="c1"># only index keys which are events (i.e. for job-centric, these are job keys, not flow keys)</span>
            <span class="n">demand_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">demand_data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;use_multiprocessing&#39;</span><span class="p">]:</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Duplicated from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1"> total demands (</span><span class="si">{}</span><span class="s1"> duplication(s)) in </span><span class="si">{}</span><span class="s1"> s.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">init_num_demands</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">demand_data</span><span class="p">[</span><span class="s1">&#39;event_time&#39;</span><span class="p">]),</span> <span class="n">num_duplications</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">demand_data</span> </div>




<div class="viewcode-block" id="duplicate_demand"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.duplicate_demand">[docs]</a><span class="k">def</span> <span class="nf">duplicate_demand</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> 
                     <span class="n">sn</span><span class="p">,</span>
                     <span class="n">dn</span><span class="p">,</span>
                     <span class="n">flow_size</span><span class="p">,</span>
                     <span class="n">event_time</span><span class="p">,</span>
                     <span class="n">duration</span><span class="p">,</span>
                     <span class="n">establish</span><span class="p">,</span>
                     <span class="n">index</span><span class="p">,</span>
                     <span class="n">num_demands</span><span class="p">,</span> 
                     <span class="n">idx</span><span class="p">,</span> 
                     <span class="n">jobs</span><span class="p">,</span>
                     <span class="n">job_ids</span><span class="p">,</span>
                     <span class="c1"># unique_ids,</span>
                     <span class="n">flow_ids</span><span class="p">,</span>
                     <span class="n">sns</span><span class="p">,</span>
                     <span class="n">dns</span><span class="p">,</span>
                     <span class="n">flow_sizes</span><span class="p">,</span>
                     <span class="n">event_times</span><span class="p">,</span>
                     <span class="n">establishes</span><span class="p">,</span>
                     <span class="n">indexes</span><span class="p">,</span>
                     <span class="n">job_centric</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">job_centric</span><span class="p">:</span>
        <span class="c1"># job id</span>
        <span class="n">job_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">num_demands</span><span class="p">)</span>
        <span class="n">job</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;job_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;job_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_id</span><span class="p">)</span>

        <span class="c1"># attrs inside job</span>
        <span class="c1"># job = copy.deepcopy(demand_data[&#39;job&#39;])[idx]</span>
        <span class="n">flow_stats</span> <span class="o">=</span> <span class="p">{</span><span class="n">flow</span><span class="p">:</span> <span class="n">job</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flow</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">job</span><span class="o">.</span><span class="n">edges</span><span class="p">}</span> 
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">flow_stats</span><span class="p">:</span>
            <span class="c1"># grab attr_dict for flow</span>
            <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">flow_stats</span><span class="p">[</span><span class="n">flow</span><span class="p">][</span><span class="s1">&#39;attr_dict&#39;</span><span class="p">]</span>

            <span class="c1"># update ids</span>
            <span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;job_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;job_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="n">num_demands</span><span class="p">)</span>
            <span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;unique_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;job_id&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;flow_id&#39;</span><span class="p">]</span>

            <span class="c1"># flow src, dst, &amp; size</span>
            <span class="c1"># if data dependency, is a flow</span>
            <span class="k">if</span> <span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;dependency_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;data_dep&#39;</span><span class="p">:</span>
                <span class="n">flow_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;unique_id&#39;</span><span class="p">])</span>
                <span class="n">sns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">])</span>
                <span class="n">dns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;dn&#39;</span><span class="p">])</span>
                <span class="n">flow_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;flow_size&#39;</span><span class="p">])</span>

            <span class="c1"># confirm updates</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">attr_dict</span><span class="p">[</span><span class="s1">&#39;edge&#39;</span><span class="p">]</span>
            <span class="n">job</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">attr_dict</span><span class="o">=</span><span class="n">attr_dict</span><span class="p">)</span>

        <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="n">job_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;job_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_id</span><span class="p">))</span>


    <span class="k">else</span><span class="p">:</span>
        <span class="n">flow_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;flow_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="n">num_demands</span><span class="p">)))</span>
        <span class="n">flow_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flow_size</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sn</span><span class="p">)</span>
        <span class="n">dns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span>

    <span class="n">event_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duration</span> <span class="o">+</span> <span class="n">event_time</span><span class="p">)</span>
    <span class="n">establishes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">establish</span><span class="p">)</span>
    <span class="n">indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">num_demands</span><span class="p">)</span></div>

    <span class="c1"># time.sleep(0.1)</span>







<div class="viewcode-block" id="gen_network_skewness_heat_maps"><a class="viewcode-back" href="../../../../trafpy.generator.src.html#trafpy.generator.src.flowcentric.gen_network_skewness_heat_maps">[docs]</a><span class="k">def</span> <span class="nf">gen_network_skewness_heat_maps</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> 
                                   <span class="n">num_skewed_nodes</span><span class="o">=</span><span class="p">[],</span> 
                                   <span class="n">loads</span><span class="o">=</span><span class="p">[],</span> 
                                   <span class="n">roof_skew_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                   <span class="n">labeled_grid_resolution</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                                   <span class="n">min_skewed_traffic_requested</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
                                   <span class="n">max_skewed_traffic_requested</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                   <span class="n">print_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">path_to_save</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Assumptions:</span>
<span class="sd">        - All endpoints in network have equal bandwidth capacity, and this</span>
<span class="sd">            capacity is 1/n of the overall network capacity, where n is the</span>
<span class="sd">            number of endpoints in the network.</span>
<span class="sd">        - Skewness is simply a skew factor, which is the fractional difference </span>
<span class="sd">            between traffic_per_skewed_node and traffic_per_non_skewed_node</span>
<span class="sd">        - All nodes are either skewed (by the same amount) or not skewed (by the same amount)</span>

<span class="sd">    Args:</span>
<span class="sd">        network (object)</span>
<span class="sd">        num_skewed_nodes (list): List of number of nodes to skew. Forms y-axis</span>
<span class="sd">            on heat map.</span>
<span class="sd">        loads (list): List of overall loads to apply to network (length of loads</span>
<span class="sd">            list determines the number of heat maps generated).</span>
<span class="sd">        min_skewed_traffic_requested (float): Minimum proportion of overall traffic</span>
<span class="sd">            requested by skewed nodes. Must be between 0 and 1. Forms minimum of</span>
<span class="sd">            heat map x-axis (matrix rows).</span>
<span class="sd">        max_skewed_traffic_requested (float): Maximum proportion of overall traffic</span>
<span class="sd">            requested by skewed nodes. Must be between 0 and 1. Forms maximum of</span>
<span class="sd">            heat map x-axis (matrix columns).</span>
<span class="sd">        show_fig (bool): Whether or not to display colour map.</span>

<span class="sd">    Returns skewed_nodes_traffic_requested (y-axis coords), proportion_nodes_skewed</span>
<span class="sd">    (x-axis coords), heat_maps (2D matrix of skewness values for x-y coords), and</span>
<span class="sd">    list of colour map matplotlib figures.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_skewed_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">num_skewed_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">proportion_nodes_skewed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">num_skewed</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">num_skewed</span> <span class="ow">in</span> <span class="n">num_skewed_nodes</span><span class="p">])</span>

    <span class="n">step_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_skewed_traffic_requested</span><span class="o">-</span><span class="n">min_skewed_traffic_requested</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_skewed_nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">skewed_nodes_traffic_requested</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_skewed_traffic_requested</span><span class="p">,</span> <span class="n">max_skewed_traffic_requested</span><span class="o">+</span><span class="n">step_size</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">skewed_nodes_traffic_requested</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># pcolormesh requires X and Y to be 1 larger dimension than Z or will cut out values</span>
    <span class="n">skewed_nodes_traffic_requested</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skewed_nodes_traffic_requested</span><span class="p">,</span> <span class="p">(</span><span class="n">skewed_nodes_traffic_requested</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">skewed_nodes_traffic_requested</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">skewed_nodes_traffic_requested</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">proportion_nodes_skewed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proportion_nodes_skewed</span><span class="p">,</span> <span class="p">(</span><span class="n">proportion_nodes_skewed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">proportion_nodes_skewed</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">proportion_nodes_skewed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loads</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">loads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">loads</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">load</span> <span class="ow">in</span> <span class="n">loads</span><span class="p">]</span>

    <span class="n">max_traffic_per_ep</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max traffic per ep: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_traffic_per_ep</span><span class="p">))</span>

    <span class="c1"># max possible node skew is where have highest network load w/ lowest no. skewed nodes w/ highest traffic per skew</span>
    <span class="c1"># max_node_skew = max(x for x in skewed_nodes_traffic_requested if x != 0) * max(x for x in loads if x != 0) * min(x for x in num_skewed_nodes if x != 0)</span>
    <span class="c1"># min_node_skew = min(x for x in skewed_nodes_traffic_requested if x != 0) * min(x for x in loads if x != 0) * max(x for x in num_skewed_nodes if x != 0)</span>
    <span class="c1"># print(min_node_skew, max_node_skew)</span>

    <span class="n">figs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heat_maps</span> <span class="o">=</span> <span class="p">{</span><span class="n">load</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">load</span> <span class="ow">in</span> <span class="n">loads</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">load</span> <span class="ow">in</span> <span class="n">loads</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">load </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">load</span><span class="p">))</span>
        <span class="c1"># rows (y) -&gt; skewed nodes, columns (x) -&gt; traffic requested</span>
        <span class="n">heat_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">num_skewed_nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">skewed_nodes_traffic_requested</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">num_skewed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">num_skewed_nodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">traffic_idx</span><span class="p">,</span> <span class="n">traffic_all_skewed_nodes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">skewed_nodes_traffic_requested</span><span class="p">):</span>
                <span class="n">traffic_per_skewed_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">traffic_all_skewed_nodes</span> <span class="o">/</span> <span class="n">num_skewed</span><span class="p">)</span> <span class="o">*</span> <span class="n">load</span>
                <span class="n">traffic_per_non_skewed_node</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">traffic_all_skewed_nodes</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">num_skewed</span><span class="p">))</span> <span class="o">*</span> <span class="n">load</span>
                <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num skewed nodes: </span><span class="si">{}</span><span class="s1"> | traffic all skewed nodes: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_skewed</span><span class="p">,</span> <span class="n">traffic_all_skewed_nodes</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;traffic per skewed node: </span><span class="si">{}</span><span class="s1"> | traffic per non skewed node: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traffic_per_skewed_node</span><span class="p">,</span> <span class="n">traffic_per_non_skewed_node</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">traffic_per_skewed_node</span> <span class="o">&gt;</span> <span class="n">max_traffic_per_ep</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;skewed nodes excess! distribute excess amongst non-skewed nodes&#39;</span><span class="p">)</span>
                    <span class="c1"># distribute excess amongst non-skewed nodes</span>
                    <span class="n">excess_per_node</span> <span class="o">=</span> <span class="n">traffic_per_skewed_node</span> <span class="o">-</span> <span class="n">max_traffic_per_ep</span>
                    <span class="n">total_excess</span> <span class="o">=</span> <span class="n">excess_per_node</span> <span class="o">*</span> <span class="n">num_skewed</span>
                    <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;excess per node: </span><span class="si">{}</span><span class="s1"> | total excess: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">excess_per_node</span><span class="p">,</span> <span class="n">total_excess</span><span class="p">))</span>
                    <span class="n">traffic_per_non_skewed_node</span> <span class="o">+=</span> <span class="p">(</span><span class="n">total_excess</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">num_skewed</span><span class="p">))</span>
                    <span class="n">traffic_per_skewed_node</span> <span class="o">=</span> <span class="n">max_traffic_per_ep</span>
                    <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;traffic per skewed node: </span><span class="si">{}</span><span class="s1"> | traffic per non skewed node: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traffic_per_skewed_node</span><span class="p">,</span> <span class="n">traffic_per_non_skewed_node</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">traffic_per_non_skewed_node</span> <span class="o">&gt;</span> <span class="n">max_traffic_per_ep</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;non-skewed nodes excess! distribute excess amongst skewed nodes&#39;</span><span class="p">)</span>
                    <span class="c1"># distribute excess amongst skewed nodes:</span>
                    <span class="n">excess_per_node</span> <span class="o">=</span> <span class="n">traffic_per_non_skewed_node</span> <span class="o">-</span> <span class="n">max_traffic_per_ep</span>
                    <span class="n">total_excess</span> <span class="o">=</span> <span class="n">excess_per_node</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;endpoints&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">num_skewed</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;excess per node: </span><span class="si">{}</span><span class="s1"> | total excess: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">excess_per_node</span><span class="p">,</span> <span class="n">total_excess</span><span class="p">))</span>
                    <span class="n">traffic_per_skewed_node</span> <span class="o">+=</span> <span class="p">(</span><span class="n">total_excess</span><span class="o">/</span><span class="n">num_skewed</span><span class="p">)</span>
                    <span class="n">traffic_per_non_skewed_node</span> <span class="o">=</span> <span class="n">max_traffic_per_ep</span>
                    <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;traffic per skewed node: </span><span class="si">{}</span><span class="s1"> | traffic per non skewed node: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traffic_per_skewed_node</span><span class="p">,</span> <span class="n">traffic_per_non_skewed_node</span><span class="p">))</span>
                <span class="c1"># skew = abs(traffic_per_skewed_node - traffic_per_non_skewed_node) / (max_traffic_per_ep)</span>

                <span class="c1"># roof = 2 # factor beyond which we say the traffic is &#39;very skewed&#39;</span>
                <span class="c1"># skew = min(max([traffic_per_skewed_node, traffic_per_non_skewed_node]) / min([traffic_per_skewed_node, traffic_per_non_skewed_node]), roof)</span>

                <span class="n">skew</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">traffic_per_skewed_node</span><span class="p">,</span> <span class="n">traffic_per_non_skewed_node</span><span class="p">])</span> <span class="o">/</span> <span class="nb">min</span><span class="p">([</span><span class="n">traffic_per_skewed_node</span><span class="p">,</span> <span class="n">traffic_per_non_skewed_node</span><span class="p">])</span>
                <span class="c1"># if np.isnan(skew) or np.isinf(skew):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">skew</span><span class="p">):</span>
                    <span class="n">skew</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">print_data</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;skew: </span><span class="si">{}</span><span class="s1"> (node idx </span><span class="si">{}</span><span class="s1"> traff idx </span><span class="si">{}</span><span class="s1"> load </span><span class="si">{}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">skew</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">traffic_idx</span><span class="p">,</span> <span class="n">load</span><span class="p">))</span>
                <span class="n">heat_map</span><span class="p">[</span><span class="n">max_idx</span><span class="o">-</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">max_idx</span><span class="o">-</span><span class="n">traffic_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">skew</span>

        <span class="c1"># store heat map</span>
        <span class="n">heat_maps</span><span class="p">[</span><span class="n">load</span><span class="p">]</span> <span class="o">=</span> <span class="n">heat_map</span>
        <span class="k">if</span> <span class="n">path_to_save</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tools</span><span class="o">.</span><span class="n">pickle_data</span><span class="p">(</span><span class="n">path_to_save</span><span class="o">+</span><span class="s1">&#39;heat_map_load_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">load</span><span class="p">),</span> <span class="n">heat_map</span><span class="p">)</span>

        <span class="c1"># plot heat map</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Load </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">load</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;path_to_save&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_to_save</span><span class="o">+</span><span class="s1">&#39;heat_map_load_</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">load</span><span class="p">)</span>
        <span class="n">figs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot_dists</span><span class="o">.</span><span class="n">plot_heat_map</span><span class="p">(</span><span class="n">proportion_nodes_skewed</span><span class="p">,</span> <span class="n">skewed_nodes_traffic_requested</span><span class="p">,</span> <span class="n">heat_map</span><span class="p">,</span> <span class="n">roof_skew_factor</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;plot_labeled_heat_map&#39;</span><span class="p">]:</span>
            <span class="c1"># plot annotated grid of skew values</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;path_to_save&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_to_save</span><span class="o">+</span><span class="s1">&#39;labeled_heat_map_load_</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">load</span><span class="p">)</span>
            <span class="n">figs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot_dists</span><span class="o">.</span><span class="n">plot_labeled_heat_map</span><span class="p">(</span><span class="n">proportion_nodes_skewed</span><span class="p">,</span> <span class="n">skewed_nodes_traffic_requested</span><span class="p">,</span> <span class="n">heat_map</span><span class="p">,</span> <span class="n">labeled_grid_resolution</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>


    <span class="k">return</span> <span class="n">skewed_nodes_traffic_requested</span><span class="p">,</span> <span class="n">proportion_nodes_skewed</span><span class="p">,</span> <span class="n">heat_maps</span><span class="p">,</span> <span class="n">figs</span></div>





            



    












</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Christopher W. F. Parsonson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>